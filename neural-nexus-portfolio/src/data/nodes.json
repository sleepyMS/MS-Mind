{
  "nodes": [
    {
      "id": "me",
      "type": "main",
      "label": "Min Seok",
      "connections": [
        "project-chatbot",
        "project-portfolio",
        "project-processing",
        "project-cortex",
        "project-cortex-fe",
        "project-paper-lstm",
        "project-paper-tft"
      ],
      "details": {
        "description": "창의적인 개발자로서, 최신 기술을 활용한 몰입형 웹 경험을 만드는 것에 열정을 가지고 있습니다.",
        "technologies": ["React", "TypeScript", "Three.js", "Node.js", "Python"]
      },
      "color": "#00ffff"
    },
    {
      "id": "project-chatbot",
      "type": "project",
      "label": "GangNaengBot-Frontend",
      "connections": [
        "me",
        "skill-react",
        "skill-typescript",
        "skill-vite",
        "skill-tailwind",
        "skill-zustand",
        "skill-axios",
        "skill-i18next"
      ],
      "details": {
        "description": "강남대학교 학생들을 위한 AI 챗봇 서비스 강냉봇의 프론트엔드 프로젝트입니다. 사용자에게 친숙한 대화형 인터페이스를 통해 학교 생활에 필요한 정보를 쉽고 빠르게 제공합니다.",
        "technologies": [
          "React",
          "TypeScript",
          "Vite",
          "TailwindCSS",
          "Zustand",
          "Axios",
          "i18next"
        ],
        "coreFeatures": [
          "📱 모바일 퍼스트 반응형 디자인 (Mobile-First Responsive)",
          "🎨 시스템 테마 동기화 다크모드 (System-Sync Dark Mode)",
          "⚡️ 낙관적 UI 기반의 즉각적인 채팅 경험 (Optimistic UI)",
          "🌐 4개 국어 지원 글로벌 서비스 (Global i18n)"
        ],
        "techStackDocs": [
          {
            "name": "React & TypeScript",
            "description": "강력한 컴포넌트 기반 UI 구축 및 정적 타이핑을 통한 안정성 확보"
          },
          {
            "name": "Vite",
            "description": "초고속 HMR 및 빌드 성능을 제공하여 개발 생산성 극대화"
          },
          {
            "name": "TailwindCSS",
            "description": "Utility-First 접근 방식으로 일관된 디자인 시스템 구축 및 빠른 스타일링"
          },
          {
            "name": "Zustand",
            "description": "Redux 대비 낮은 러닝커브와 보일러플레이트 없는 직관적인 전역 상태 관리"
          },
          {
            "name": "Axios",
            "description": "인터셉터를 활용한 효율적인 토큰 관리 및 에러 핸들링 중앙화"
          },
          {
            "name": "i18next",
            "description": "외국인 학생들을 위한 확장 가능한 다국어 지원 구조 설계 (KO, EN, JA, ZH)"
          }
        ],
        "link": "https://github.com/sleepyMS/GangNaengBot-FE",
        "deployLink": "https://gang-naeng-bot-fe.vercel.app/",
        "features": [
          {
            "title": "채팅 시스템 (Chat System)",
            "items": [
              "상태 관리: Zustand를 사용하여 useChatStore에서 세션, 메시지, 로딩 상태 등을 전역적으로 관리합니다.",
              "낙관적 UI (Optimistic UI): 메시지 전송 시 서버 응답을 기다리지 않고 즉시 UI에 사용자의 메시지를 표시합니다. sendMessage 함수 내에서 set을 통해 로컬 메시지 배열을 먼저 업데이트하고, 백그라운드에서 API 호출을 수행합니다. 실패 시 messages.slice(0, -1)을 통해 롤백하여 데이터 일관성을 유지합니다.",
              "재시도 로직 (Retry Logic): AI 응답이 비어있거나 실패할 경우를 대비하여 sendMessage 내부에서 최대 5회, 500ms 간격으로 재시도하는 로직을 구현했습니다. 이를 통해 일시적인 네트워크 오류나 서버 지연에 강건하게 대응합니다.",
              "세션 관리: 첫 메시지 전송 시 자동으로 세션을 생성(createSession)하고, 이후 메시지는 해당 세션 ID(sid)로 전송됩니다. 게스트 모드 지원을 위해 guestUserId를 별도로 관리합니다."
            ]
          },
          {
            "title": "인증 및 보안 (Authentication)",
            "items": [
              "API 클라이언트 (apiClient.ts): axios.create로 기본 설정을 중앙화했습니다.",
              "Request Interceptor: 모든 요청의 헤더에 localStorage에 저장된 access_token을 자동으로 Bearer 토큰으로 추가합니다.",
              "Response Interceptor: 401 Unauthorized 에러 발생 시 자동으로 토큰을 삭제하고 로그인 페이지로 리다이렉트 처리하여 보안을 강화했습니다. 기타 에러(403, 404, 500 등)에 대해 표준화된 에러 메시지를 반환하도록 처리했습니다."
            ]
          },
          {
            "title": "다국어 지원 (Global i18n)",
            "items": [
              "설정 (i18n/index.ts): react-i18next를 도입하여 한국어, 영어, 일본어, 중국어 4개 국어를 지원합니다. 언어 리소스를 JSON 파일로 관리하며, 초기 로드 시 브라우저 언어 감지 또는 저장된 설정을 따릅니다.",
              "UI 컴포넌트 (LanguageSwitcher.tsx): 드롭다운 메뉴를 통해 언어를 실시간으로 변경할 수 있습니다. 변경 시 useSettingsStore와 i18next 인스턴스를 동기화하여 앱 전체에 즉시 반영됩니다."
            ]
          },
          {
            "title": "테마 시스템 (Dark/Light Mode)",
            "items": [
              "Tailwind CSS: darkMode: 'class' 설정을 사용하여 HTML root 요소의 클래스(dark) 유무에 따라 스타일을 제어합니다.",
              "상태 관리 (useSettingsStore.ts): persist 미들웨어를 사용하여 사용자의 테마 설정을 로컬 스토리지에 영구 저장합니다. system 모드 선택 시 window.matchMedia('(prefers-color-scheme: dark') 리스너를 등록하여 OS 테마 변경에 실시간으로 반응합니다."
            ]
          },
          {
            "title": "프로필 관리 (Profile Modal)",
            "items": [
              "계층형 드롭다운: 단과대 -> 학부 -> 전공 순으로 선택하며, 상위 항목 선택 시 하위 목록이 필터링되는 의존성(Dependency) 관계를 구현했습니다. 상태 변경 시 하위 선택값을 자동으로 초기화하여 데이터 무결성을 보장합니다.",
              "반응형 디자인: window.innerWidth를 감지하여 모바일과 데스크톱에서 서로 다른 레이아웃(전체 화면 모달 vs 팝업 모달)을 렌더링합니다."
            ]
          }
        ],
        "optimizations": [
          {
            "title": "지능형 데이터 프리페칭 (Intelligent Data Prefetching)",
            "items": [
              "호버 프리페칭 (Hover Prefetching): 사이드바의 세션 목록에 마우스를 올리는 순간(onMouseEnter), 해당 세션의 메시지 데이터를 백그라운드에서 미리 요청합니다.",
              "중복 요청 방지 (Request Deduplication): Map 자료구조를 활용한 pendingPrefetches 캐시를 도입했습니다. 이미 로딩 중인 세션에 대해 중복된 API 호출이 발생하지 않도록, 진행 중인 Promise를 재사용하여 네트워크 리소스를 절약했습니다. Race Condition을 효과적으로 방지했습니다."
            ]
          },
          {
            "title": "클라이언트 사이드 캐싱 (Client-Side Caching)",
            "items": [
              "메시지 캐시 (messageCache): useChatStore 내부에 Map<string, MessageItem[]> 형태의 캐시를 두어, 한 번 불러온 세션의 대화 내용은 메모리에 저장합니다. 사용자가 이전에 방문한 세션을 다시 클릭할 경우, 네트워크 요청 없이 캐시된 데이터를 즉시 렌더링하고, 백그라운드에서 조용히 최신 데이터를 동기화합니다."
            ]
          },
          {
            "title": "낙관적 UI (Optimistic UI)",
            "items": [
              "즉시 렌더링: 메시지 전송 버튼을 누르는 즉시 로컬 상태를 업데이트하여 화면에 말풍선을 표시합니다.",
              "백그라운드 처리: 실제 API 요청은 백그라운드에서 처리되며, 성공 시 상태를 유지하고 실패 시에만 롤백 처리하여 사용자 흐름을 방해하지 않습니다."
            ]
          },
          {
            "title": "번들 크기 및 리소스 최적화",
            "items": [
              "Vite 기반 빌드: ES Modules 기반의 Vite를 사용하여 개발 서버 구동 속도와 HMR(Hot Module Replacement) 속도를 극대화했습니다.",
              "Tailwind CSS JIT: 사용되는 클래스만 CSS로 컴파일되는 JIT(Just-In-Time) 모드를 통해 CSS 파일 크기를 최소화했습니다."
            ]
          }
        ],
        "challenges": [
          {
            "title": "비동기 데이터와 UI 동기화 문제 (Chat UX)",
            "problem": "사용자가 메시지를 보낸 후, 서버로부터 AI의 응답이 올 때까지의 지연 시간(Latency) 동안 화면이 정지된 것처럼 보이는 문제가 있었습니다. 또한, 네트워크 상태가 불안정할 때 요청이 실패하면 사용자는 메시지가 보내졌는지 알 수 없어 혼란스러워했습니다.",
            "solution": "낙관적 업데이트(Optimistic Update)를 적용하여 서버 응답을 기다리지 않고 로컬 상태에 즉시 메시지를 추가했습니다. 또한 try-catch 블록과 상태 롤백을 활용해 실패 시 데이터를 복구하고, 백그라운드 재시도(Retry) 로직을 구현하여 일시적인 오류를 자동으로 복구했습니다."
          },
          {
            "title": "복잡한 계층형 폼 데이터 관리",
            "problem": "프로필 수정 페이지에서 '단과대학 → 학부 → 전공'으로 이어지는 계층적 데이터 구조를 처리해야 했습니다. 상위 항목 변경 시 하위 항목이 초기화되지 않거나, 잘못된 조합이 선택된 채로 남는 버그가 발생하기 쉬웠습니다.",
            "solution": "의존성 기반 상태 초기화 로직을 handleChange 함수에 통합하여, 상위 필드 변경 시 연관된 하위 필드들을 명시적으로 초기화했습니다. 또한 상수 객체를 활용해 상위 키값에 따라 하위 옵션을 실시간으로 계산하여 렌더링하도록 구현했습니다."
          },
          {
            "title": "다크 모드 깜빡임 (FOUC)",
            "problem": "페이지 새로고침 시, 자바스크립트가 로드되고 테마 상태를 읽어오기 전까지 짧은 순간 흰색 배경이 보였다가 다크 모드로 변하는 '깜빡임(Flash of Unstyled Content)' 현상이 발생했습니다.",
            "solution": "Zustand의 persist 미들웨어로 설정을 로컬 스토리지에 저장하고, 앱 진입 시점뿐만 아니라 스토어 초기화 시점에 즉시 document.documentElement에 dark 클래스를 주입하여 렌더링 이전에 테마가 적용되도록 했습니다."
          },
          {
            "title": "인증 토큰 만료 처리",
            "problem": "access_token이 만료되었을 때, 사용자가 이를 인지하지 못하고 계속 API 요청을 보내면 401 에러가 발생하고 앱이 동작하지 않는 것처럼 보이는 문제가 있었습니다.",
            "solution": "Axios Interceptor를 중앙화하여 401 에러를 전역적으로 감지하고, 발생 시 즉시 로컬 스토리지의 토큰을 삭제하고 로그인 페이지로 강제 이동시켜 자연스러운 재로그인 흐름을 만들었습니다."
          }
        ],
        "learnings": [
          {
            "title": "UX 중심의 상태 관리 중요성",
            "content": "단순히 데이터를 화면에 보여주는 것을 넘어, 사용자가 느끼는 속도(Perceived Performance)가 실제 속도보다 중요하다는 것을 깨달았습니다. 낙관적 UI와 스켈레톤 로딩, 백그라운드 동기화 전략을 조합하여 체감 지연 시간을 획기적으로 줄일 수 있었습니다."
          },
          {
            "title": "확장 가능한 아키텍처 설계",
            "content": "코드가 커질수록 재사용 가능한 컴포넌트와 중앙화된 설정의 중요성을 절감했습니다. apiClient를 통한 네트워크 요청 중앙화는 유지보수성과 보안성을 높여주었고, 공통 컴포넌트 추상화는 복잡한 비즈니스 로직 구현을 수월하게 만들었습니다."
          },
          {
            "title": "선언적 UI와 비즈니스 로직의 분리",
            "content": "컴포넌트는 '어떻게 보여줄 것인가'에 집중하고, 데이터 페칭이나 상태 변경 로직은 커스텀 훅이나 스토어로 위임함으로써 코드의 가독성과 테스트 용이성을 높일 수 있었습니다."
          },
          {
            "title": "다국어 지원(i18n)의 조기 도입 가치",
            "content": "프로젝트 중반에 도입하려 했으나 구조적인 변경이 필요했습니다. 이를 통해 확장성을 고려한 설계는 프로젝트 초기에 이루어져야 한다는 점을 배웠으며, i18next의 강력한 기능을 통해 효과적으로 다국어 경험을 제공할 수 있었습니다."
          }
        ]
      },
      "color": "#ff00ff"
    },
    {
      "id": "project-portfolio",
      "type": "project",
      "label": "Neural Portfolio",
      "connections": ["me", "skill-threejs", "skill-react", "skill-gsap"],
      "details": {
        "description": "지금 보고 계신 포트폴리오입니다! 프로젝트들을 상호 연결된 뉴런으로 시각화한 3D 신경망 기반 포트폴리오입니다.",
        "trouble": "많은 노드와 연결선을 유지하면서 부드러운 카메라 애니메이션과 60fps 성능을 달성하는 것이 어려웠습니다.",
        "shooting": "Instanced Mesh, 최적화된 셰이더, 하드웨어 가속 애니메이션을 위한 GSAP을 활용했습니다.",
        "lesson": "WebGL 성능 최적화와 커스텀 셰이더의 강력함에 대해 깊이 이해하게 되었습니다.",
        "technologies": ["React", "Three.js", "GSAP", "TypeScript"]
      },
      "color": "#ff00ff"
    },
    {
      "id": "project-processing",
      "type": "project",
      "label": "Processing Games",
      "connections": ["me", "skill-processing", "skill-arduino"],
      "details": {
        "description": "Processing으로 제작한 인터랙티브 게임 컬렉션입니다. Arduino 조이스틱 컨트롤을 통해 하드웨어와 소프트웨어를 연동했습니다.",
        "trouble": "Arduino 입력을 게임 상태와 동기화하고 다양한 게임 모드를 처리하는 것이 어려웠습니다.",
        "shooting": "모든 게임 모드에서 하드웨어 컨트롤을 추상화하는 모듈식 입력 시스템을 구축했습니다.",
        "lesson": "하드웨어-소프트웨어 통합에는 타이밍과 상태 관리에 대한 세심한 고려가 필요합니다.",
        "technologies": ["Processing", "Arduino", "Java"]
      },
      "color": "#ff00ff"
    },
    {
      "id": "skill-react",
      "type": "skill",
      "label": "React 19",
      "connections": ["project-chatbot", "project-portfolio"],
      "details": {
        "description": "Meta에서 개발한 UI 라이브러리로, Hooks를 활용한 함수형 컴포넌트 개발을 지원합니다. 선언적 UI 패러다임과 Virtual DOM을 통해 효율적인 렌더링을 제공하며, Concurrent Mode와 Server Components 같은 최신 기능으로 대규모 애플리케이션 개발에 적합합니다."
      },
      "color": "#61dafb"
    },
    {
      "id": "skill-typescript",
      "type": "skill",
      "label": "TypeScript",
      "connections": ["project-chatbot", "project-cortex-fe"],
      "details": {
        "description": "Microsoft에서 개발한 JavaScript의 슈퍼셋으로, 정적 타입 검사를 통해 컴파일 시점에 오류를 잡아냅니다. 인터페이스, 제네릭, 유니온 타입 등 강력한 타입 시스템으로 대규모 애플리케이션의 안정성과 유지보수성을 크게 향상시킵니다."
      },
      "color": "#3178c6"
    },
    {
      "id": "skill-threejs",
      "type": "skill",
      "label": "Three.js / R3F",
      "connections": ["project-portfolio"],
      "details": {
        "description": "WebGL 기반의 3D 그래픽 라이브러리로, 브라우저에서 고품질 3D 경험을 구현합니다. React Three Fiber(R3F)를 통해 React와 선언적으로 통합 가능하며, 커스텀 셰이더 작성, 포스트 프로세싱, 물리 엔진 연동 등 고급 그래픽 기법을 지원합니다."
      },
      "color": "#049ef4"
    },
    {
      "id": "skill-gsap",
      "type": "skill",
      "label": "GSAP",
      "connections": ["project-portfolio"],
      "details": {
        "description": "GreenSock Animation Platform의 약자로, 웹에서 가장 강력한 JavaScript 애니메이션 라이브러리입니다. 하드웨어 가속, 타임라인 기반 시퀀싱, ScrollTrigger 플러그인 등을 통해 부드럽고 성능 최적화된 애니메이션을 구현합니다."
      },
      "color": "#88ce02"
    },
    {
      "id": "skill-python",
      "type": "skill",
      "label": "Python",
      "connections": ["project-cortex", "project-paper-lstm"],
      "details": {
        "description": "데이터 분석, 머신러닝, 백엔드 개발 등 다양한 분야에서 활용되는 범용 프로그래밍 언어입니다."
      },
      "color": "#3776ab"
    },
    {
      "id": "skill-fastapi",
      "type": "skill",
      "label": "FastAPI",
      "connections": ["project-cortex"],
      "details": {
        "description": "Python 기반의 고성능 비동기 웹 프레임워크로, 자동 API 문서화와 타입 힌트 지원을 제공합니다."
      },
      "color": "#009688"
    },
    {
      "id": "skill-processing",
      "type": "skill",
      "label": "Processing",
      "connections": ["project-processing"],
      "details": {
        "description": "MIT 미디어 연구소에서 개발한 비주얼 아트와 크리에이티브 코딩을 위한 프로그래밍 언어 및 IDE입니다. Java 기반으로 동작하며, 인터랙티브 그래픽, 애니메이션, 데이터 시각화 등 시각 예술 작품을 쉽게 제작할 수 있습니다."
      },
      "color": "#006699"
    },
    {
      "id": "skill-arduino",
      "type": "skill",
      "label": "Arduino",
      "connections": ["project-processing"],
      "details": {
        "description": "오픈소스 하드웨어 플랫폼으로, 마이크로컨트롤러 기반의 프로토타이핑 보드입니다. 센서, 모터, LED 등 다양한 전자 부품을 제어할 수 있으며, IoT 프로젝트와 인터랙티브 설치 작품 개발에 널리 사용됩니다."
      },
      "color": "#00979d"
    },
    {
      "id": "skill-vite",
      "type": "skill",
      "label": "Vite",
      "connections": ["project-chatbot"],
      "details": {
        "description": "차세대 프론트엔드 빌드 도구로, ES Modules 기반의 초고속 개발 서버와 HMR(Hot Module Replacement)을 제공합니다. Rollup 기반 번들링으로 최적화된 프로덕션 빌드를 생성하며, React, Vue, Svelte 등 다양한 프레임워크를 지원합니다."
      },
      "color": "#646cff"
    },
    {
      "id": "skill-tailwind",
      "type": "skill",
      "label": "TailwindCSS",
      "connections": ["project-chatbot", "project-cortex-fe"],
      "details": {
        "description": "Utility-First 방식의 CSS 프레임워크로, 미리 정의된 유틸리티 클래스를 조합하여 빠르게 스타일링합니다. JIT 컴파일러로 사용된 클래스만 번들에 포함되어 최소한의 CSS 파일을 생성하며, 일관된 디자인 시스템 구축에 적합합니다."
      },
      "color": "#38bdf8"
    },
    {
      "id": "skill-zustand",
      "type": "skill",
      "label": "Zustand",
      "connections": ["project-chatbot", "project-cortex-fe"],
      "details": {
        "description": "가볍고 빠른 React 상태 관리 라이브러리입니다. Redux 대비 보일러플레이트가 적고 러닝커브가 낮으며, 훅 기반의 직관적인 API를 제공합니다. Immer와 함께 사용하면 복잡한 중첩 상태도 쉽게 관리할 수 있습니다."
      },
      "color": "#4338ca"
    },
    {
      "id": "skill-axios",
      "type": "skill",
      "label": "Axios",
      "connections": ["project-chatbot"],
      "details": {
        "description": "Promise 기반의 HTTP 클라이언트로, 브라우저와 Node.js 환경 모두에서 동작합니다. 인터셉터를 통한 요청/응답 가로채기, 자동 JSON 변환, 요청 취소, 타임아웃 설정 등 API 통신에 필요한 다양한 기능을 제공합니다."
      },
      "color": "#5a29e4"
    },
    {
      "id": "skill-i18next",
      "type": "skill",
      "label": "i18next",
      "connections": ["project-chatbot"],
      "details": {
        "description": "가장 널리 사용되는 JavaScript 국제화(i18n) 프레임워크입니다. 다국어 리소스 관리, 복수형 처리, 언어 감지, 지연 로딩 등 다국어 지원에 필요한 포괄적인 기능을 제공하며, React, Vue 등 다양한 프레임워크와 통합됩니다."
      },
      "color": "#26a69a"
    },
    {
      "id": "project-cortex",
      "type": "project",
      "label": "Cortex-Backend",
      "connections": [
        "me",
        "skill-python",
        "skill-celery",
        "skill-redis",
        "skill-timescaledb",
        "skill-docker",
        "skill-postgresql",
        "project-cortex-fe"
      ],
      "details": {
        "description": "개인 투자자를 위한 데이터 기반 퀀트 투자 및 자동매매 플랫폼입니다. 사용자가 코딩 없이 UI로 투자 전략을 수립하면, 시스템이 과거 데이터를 기반으로 수익률을 검증(백테스팅)하고, 실제 거래소와 연동하여 24시간 자동매매를 수행합니다.",
        "technologies": [
          "FastAPI",
          "Celery",
          "Redis",
          "TimescaleDB",
          "PostgreSQL",
          "Docker",
          "Python 3.11"
        ],
        "coreFeatures": [
          "🏗️ Modular Monolith 아키텍처 (MSA 전환 고려)",
          "⚡ CPU/I/O 분리 비동기 분산 처리 시스템",
          "📊 대용량 시계열 데이터 처리 (TimescaleDB)",
          "💰 Double-Entry 기반 크레딧 경제 시스템",
          "📡 실시간 진행률 피드백 (Redis Pub/Sub + WebSocket)",
          "📈 고급 데이터 분석 시각화 (평행좌표플롯, fANOVA)"
        ],
        "techStackDocs": [
          {
            "name": "FastAPI",
            "description": "Pydantic 기반 스키마 검증과 비동기 처리로 High Concurrency 환경에서 빠른 응답 제공"
          },
          {
            "name": "Celery",
            "description": "CPU-bound(백테스팅)와 I/O-bound(거래소 통신) 작업을 워커 노드로 분리하여 웹 서버 블로킹 방지"
          },
          {
            "name": "Redis",
            "description": "Message Broker로 활용하여 서비스 간 결합도를 낮추고, Pub/Sub으로 실시간 진행률 업데이트 구현"
          },
          {
            "name": "TimescaleDB",
            "description": "Hypertables 자동 파티셔닝으로 대용량 OHLCV 데이터의 디스크 I/O 최소화 및 조회 성능 최적화"
          },
          {
            "name": "Docker",
            "description": "단일 이미지, 다수 CMD 전략으로 API/CPU Worker/I/O Worker를 일관되게 배포"
          },
          {
            "name": "PostgreSQL",
            "description": "관계형 데이터(User, Strategy, Backtest) 저장 및 Optuna Study 공유 저장소로 활용"
          }
        ],
        "codeExamples": [
          {
            "title": "FastAPI Lifespan으로 모듈별 초기화",
            "category": "architecture",
            "description": "각 서비스가 자신의 초기 데이터를 책임지도록 호출하여 모듈러 모놀리스 구조를 유지",
            "filePath": "backend/main.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/main.py",
            "snippet": "@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    async with async_engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    await plan_service.seed_initial_plans(session)\n    await marketplace_service.seed_credit_packs(session)"
          },
          {
            "title": "Celery 큐 분리로 CPU/I/O 격리",
            "category": "async",
            "description": "cpu_queue와 io_queue를 분리하여 백테스팅(CPU-bound)과 거래(I/O-bound) 작업 격리",
            "filePath": "backend/app/tasks.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/tasks.py",
            "snippet": "@celery_app.task(queue='cpu_queue')\ndef run_backtest(backtest_id: str):\n    # CPU 집약적 백테스팅 연산\n    ...\n\n@celery_app.task(queue='io_queue')\ndef execute_live_trade(bot_id: str):\n    # 거래소 API 통신 (I/O-bound)\n    ..."
          },
          {
            "title": "TimescaleDB Hypertables로 시계열 최적화",
            "category": "database",
            "description": "시간 단위 청크로 자동 파티셔닝하여 대용량 OHLCV 데이터 조회 성능 향상",
            "filePath": "backend/app/models.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/models.py",
            "snippet": "class OHLCV1h(Base):\n    __tablename__ = 'ohlcv_1h'\n    time = Column(DateTime(timezone=True), primary_key=True)\n    ticker = Column(Text, primary_key=True)\n    open = Column(Numeric(20, 8))\n    high = Column(Numeric(20, 8))\n    low = Column(Numeric(20, 8))\n    close = Column(Numeric(20, 8))\n    volume = Column(Numeric(20, 8))"
          },
          {
            "title": "Double-Entry 크레딧 차감 로직",
            "category": "business",
            "description": "Ledger(생성)와 Transaction(소비)을 분리하여 FIFO 우선순위 적용",
            "filePath": "backend/app/services/credit_service.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/services/credit_service.py",
            "snippet": "async def deduct_credits(self, db: AsyncSession, user_id: uuid.UUID, amount: int):\n    # 만료 임박 > 무료 > 유료 순서로 차감\n    ledgers = await self._get_ledgers_for_deduction(db, user_id)\n    for ledger in ledgers:\n        if amount <= 0: break\n        deduct_amount = min(amount, ledger.remaining_amount)\n        # Transaction 기록 및 Ledger 업데이트"
          },
          {
            "title": "Redis Pub/Sub로 실시간 진행률 피드백",
            "category": "realtime",
            "description": "Celery 워커가 진행률을 발행하고, FastAPI가 WebSocket으로 클라이언트에 푸시",
            "filePath": "backend/app/tasks.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/tasks.py",
            "snippet": "# 백테스팅 진행률 발행\nWebSocketManager.send_status_update(\n    backtest_id,\n    status='running',\n    message='시뮬레이션 실행 중...',\n    progress=75\n)"
          },
          {
            "title": "Optuna + WFO 베이지안 최적화",
            "category": "optimization",
            "description": "TPE 알고리즘으로 유망한 파라미터 영역을 집중 탐색하고, Pruning으로 조기 중단",
            "filePath": "backend/app/tasks.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/tasks.py",
            "snippet": "study = optuna.create_study(\n    storage='postgresql://...',\n    study_name=f'wfo_{strategy_id}',\n    direction='maximize',\n    pruner=optuna.pruners.MedianPruner()\n)\nstudy.optimize(\n    lambda trial: objective(trial, strategy, data),\n    n_trials=100\n)"
          },
          {
            "title": "벡터 연산으로 백테스팅 가속화",
            "category": "performance",
            "description": "Pandas/NumPy 벡터 연산으로 루프 없이 컬럼 단위 고속 처리",
            "filePath": "backend/app/core/backtesting_engine.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/core/backtesting_engine.py",
            "snippet": "# 조건문 대신 np.where로 신호 마스킹\ndf['signal'] = np.where(\n    (df['short_ma'] > df['long_ma']) & \n    (df['short_ma'].shift(1) <= df['long_ma'].shift(1)),\n    1,  # 골든크로스: 매수\n    np.where(\n        (df['short_ma'] < df['long_ma']),\n        -1,  # 데드크로스: 매도\n        0\n    )\n)"
          },
          {
            "title": "N+1 문제 해결: Eager Loading",
            "category": "troubleshooting",
            "description": "SQLAlchemy joinedload로 연관 데이터를 단 한 번의 쿼리로 가져오기",
            "filePath": "backend/app/routers/strategies.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/routers/strategies.py",
            "snippet": "# Before: N+1 문제 (1.2s)\nstrategies = await db.execute(select(Strategy))\n\n# After: Eager Loading (0.1s)\nstrategies = await db.execute(\n    select(Strategy)\n    .options(selectinload(Strategy.backtests))\n    .options(selectinload(Strategy.parameters))\n)"
          },
          {
            "title": "Decimal 타입으로 부동소수점 오차 방지",
            "category": "troubleshooting",
            "description": "금전 및 수량 관련 필드에 Decimal 타입 적용하여 정밀도 보장",
            "filePath": "backend/app/schemas.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/schemas.py",
            "snippet": "from pydantic import condecimal\n\nclass OrderCreate(BaseModel):\n    quantity: condecimal(max_digits=20, decimal_places=8)\n    price: condecimal(max_digits=20, decimal_places=8)\n    # float 대신 Decimal로 0.1 + 0.2 = 0.3 보장"
          },
          {
            "title": "금융 지표 계산 (Sharpe Ratio)",
            "category": "analytics",
            "description": "Pandas 벡터 연산으로 리스크 조정 수익률 지표 고속 계산",
            "filePath": "backend/app/core/backtesting_engine.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/core/backtesting_engine.py",
            "snippet": "def calculate_sharpe_ratio(returns: pd.Series, risk_free_rate: float = 0.02):\n    excess_returns = returns - risk_free_rate / 252\n    return np.sqrt(252) * excess_returns.mean() / excess_returns.std()"
          }
        ],
        "link": "https://github.com/sleepyMS/Cortex",
        "features": [
          {
            "title": "비동기 분산 처리 시스템 (Async Distributed System)",
            "items": [
              "Layered Architecture: Router → Service → Repository(DB) 구조로 책임을 명확히 분리하여 유지보수성 향상",
              "Resource Isolation: 단일 Docker 이미지를 공유하지만 실행 CMD를 달리하여 워커 노드를 특성별(API/CPU/I/O)로 분리",
              "Message Broker: Redis를 브로커로 사용하여 서비스 간 결합도를 낮추고 비동기 작업 큐 관리"
            ]
          },
          {
            "title": "대용량 시계열 데이터 처리 (TimescaleDB)",
            "items": [
              "Hypertables 적용: 데이터를 시간 단위 청크(Chunk)로 자동 파티셔닝하여 디스크 I/O 최소화",
              "복합 인덱싱: (ticker, time DESC) 인덱스를 구성하여 최신 시세 조회 쿼리 속도 최적화"
            ]
          },
          {
            "title": "전략 최적화 고도화 (WFO + Optuna)",
            "items": [
              "WFO(Walk-Forward Optimization): 데이터를 Train/Test 구간으로 슬라이딩하며 검증하여 과최적화 방지",
              "베이지안 최적화(TPE): Optuna를 도입, 이전 파라미터의 성과를 학습하여 유망한 파라미터 영역 집중 탐색",
              "Aggressive Pruning: 각 Fold 검증 중 수익률이 하위 50% 미만이면 즉시 연산 중단(Early Stopping)",
              "성과: WFO로 10배 늘어난 연산 시간을 Pruning으로 1/5 수준으로 단축, 안정성과 속도 모두 확보"
            ]
          },
          {
            "title": "고급 분석 지표 및 시각화 데이터 처리 (Advanced Analytics)",
            "items": [
              "금융 지표 계산: Sharpe Ratio, Sortino Ratio, MDD, Win Rate, Profit Factor, CAGR 등 10여 가지 핵심 지표를 벡터 연산으로 고속 처리",
              "파라미터 중요도 분석: Optuna의 fANOVA (Functional Analysis of Variance) 알고리즘으로 수익률에 가장 큰 영향을 미친 파라미터를 정량적으로 추출하여 API로 제공",
              "평행좌표플롯 데이터 서빙: 수천 건의 Trial 데이터(params JSONB + metrics JSONB)를 고차원 시각화 포맷에 맞게 직렬화하고, 불필요한 필드를 제외하는 DTO 최적화로 전송량 절감",
              "파라미터 안정성 추이(Stability) 분석: WFO 수행 시 각 Fold별로 최적 파라미터가 어떻게 변해가는지 추적하여 전략의 과최적화 여부를 판단할 수 있는 시계열 데이터 제공"
            ]
          },
          {
            "title": "크레딧 경제 시스템 (Double-Entry Logic)",
            "items": [
              "Credits Ledger (원장): 크레딧의 '생성'을 기록하며, 각 레코드별로 만료일(expires_at)을 개별 관리",
              "Credits Transaction: 크레딧의 '소비'를 기록하고, transaction_details로 원장별 차감 내역 추적",
              "우선순위 알고리즘: [만료 임박 > 무료(보너스) > 유료] 순서로 자동 차감되는 FIFO 변형 로직"
            ]
          },
          {
            "title": "실시간 진행률 피드백 (Redis Pub/Sub + WebSocket)",
            "items": [
              "Celery 워커가 작업 진행 중 Redis Pub/Sub 채널로 진행률 메시지 발행",
              "FastAPI 서버가 해당 채널을 구독하고, 메시지 수신 즉시 WebSocket 클라이언트로 푸시",
              "폴링(Polling) 없이 실시간으로 부드러운 Progress UI 제공 및 서버 부하 감소"
            ]
          }
        ],
        "optimizations": [
          {
            "title": "백테스팅 엔진 가속화 (Vectorization)",
            "items": [
              "Python for 루프 대신 Pandas/NumPy의 벡터 연산을 활용하여 컬럼 단위 한 번에 연산",
              "np.where()를 사용하여 조건문을 배열 단위 신호 마스킹으로 대체",
              "성과: 1년 치 1분봉 데이터(약 50만 행) 백테스팅 소요 시간 45초 → 0.8초로 98% 단축"
            ]
          },
          {
            "title": "Celery Worker 동시성 전략 차별화",
            "items": [
              "CPU Worker: -P prefork -c 4 (CPU 코어 수에 맞춤) - GIL 우회하여 멀티코어 100% 활용",
              "I/O Worker: -P gevent -c 100 (높은 동시성) - 그린 스레드로 수백 개의 동시 요청 처리",
              "작업 성격(CPU vs I/O)에 따른 실행 풀 전략 차별화로 처리량 극대화"
            ]
          },
          {
            "title": "DB 쓰기 성능 최적화 (Bulk Insert)",
            "items": [
              "SQLAlchemy Core의 bulk_insert_mappings 또는 pandas.to_sql(method='multi') 활용",
              "수천 건의 거래 로그나 캔들 데이터를 한 번의 트랜잭션으로 묶어서 저장(Batch Processing)",
              "DB 커넥션 오버헤드 대폭 감소"
            ]
          },
          {
            "title": "대규모 병렬 최적화 아키텍처",
            "items": [
              "RDB Storage 공유: Optuna Study를 PostgreSQL에 저장하여 다수의 Celery 워커가 병렬 처리",
              "메모리 누수 방지: 수천 번의 반복 백테스팅 시 gc.collect() 명시적 호출 및 대형 객체 참조 해제",
              "수십 개의 워커가 동시에 하나의 WFO 작업을 병렬로 처리하며 최적화 시간 획기적 단축"
            ]
          }
        ],
        "challenges": [
          {
            "title": "동기식 연산으로 인한 웹 서버 블로킹 (The 'Frozen' Server)",
            "problem": "Pandas를 이용한 백테스팅 연산이 CPU를 점유하자, FastAPI의 이벤트 루프가 차단되어 헬스 체크조차 실패하는 장애 발생. Python의 GIL과 CPU-bound 작업 특성상 단일 프로세스 내 무거운 연산 시 I/O 처리가 지연됨.",
            "solution": "Celery 비동기 작업 큐 도입으로 연산 작업을 웹 서버에서 완전히 분리. cpu_queue와 io_queue를 분리하여 백테스팅 요청이 폭주해도 거래소 시세 조회나 주문 실행(I/O)은 지연되지 않도록 아키텍처 개선."
          },
          {
            "title": "Windows 개발 환경에서의 Celery 호환성 문제 (OS Dependency)",
            "problem": "Windows 10/11에서 Celery 워커 실행 시 작업이 수신은 되지만 실행되지 않고 Hang되거나 ValueError와 함께 프로세스 강제 종료. Celery 4.x 이후 Windows의 spawn 방식을 지원하지 않고 Unix의 Prefork 풀을 기본값으로 사용하기 때문.",
            "solution": "단기: Windows 로컬 개발 시 --pool=solo 또는 eventlet/gevent 풀로 변경. 근본: 배포 환경을 Docker(Linux Container)로 통일하여 OS 간 차이 없이 안정적인 prefork/gevent 풀 사용."
          },
          {
            "title": "ORM의 N+1 문제로 인한 조회 성능 저하",
            "problem": "GET /strategies API에서 전략 목록과 최근 백테스트 결과를 조회할 때, 전략 개수(N)만큼 추가 SELECT 쿼리가 발생하여 응답 속도가 현저히 느려짐. SQLAlchemy의 Lazy Loading으로 인해 strategy.backtests 접근 시마다 DB 쿼리 발생.",
            "solution": "SQLAlchemy의 options(joinedload/selectinload)를 사용하여 연관 데이터를 단 한 번의 쿼리(JOIN)로 가져오도록 Eager Loading 적용. API 응답 시간 평균 1.2s → 0.1s로 약 90% 단축."
          },
          {
            "title": "부동 소수점(Floating Point) 연산 오차",
            "problem": "암호화폐 매매 수량 계산 시 float 타입을 사용하자, 0.1 + 0.2 = 0.30000000000000004 같은 미세한 오차 발생. 거래소 주문 시 '잔액 부족' 또는 '자릿수 오류' 발생 위험.",
            "solution": "금전 및 수량 관련 모든 필드(DB의 Numeric, Python 로직)를 Decimal 타입으로 전면 교체. Pydantic의 condecimal로 API 입력값 검증 단계에서 소수점 이하 자릿수 정책 엄격 제한."
          },
          {
            "title": "전략 최적화 시 과최적화(Overfitting) 문제",
            "problem": "특정 구간에서만 수익률이 높은 파라미터가 선택되어, 실제 매매 투입 시 손실 발생 위험.",
            "solution": "WFO + Optuna + Pruning 조합으로 해결. WFO로 데이터 신뢰도를 높이고, 늘어난 연산 비용은 베이지안 최적화와 공격적 가지치기로 1/10 수준으로 절감."
          }
        ],
        "learnings": [
          {
            "title": "'데이터 정합성'은 타협할 수 없는 가치",
            "content": "금융 애플리케이션에서 데이터 무결성은 신뢰와 직결됩니다. 전략 수정 시 과거 백테스트 결과가 변하지 않도록 JSON Snapshot을 도입하고, Decimal 타입으로 연산 오차를 제어하며, 현금 정산과 크레딧 시스템을 분리 설계한 경험은 엔지니어로서의 윤리와 책임감을 배우는 계기가 되었습니다."
          },
          {
            "title": "MSA로 가는 징검다리: 모듈러 모놀리스(Modular Monolith)",
            "content": "처음부터 MSA로 시작하는 것은 오버엔지니어링이 될 수 있음을 깨달았습니다. 코드베이스는 하나로 유지하되, Auth/Backtest/Trade 등 도메인 간 경계를 명확히 하고 서비스 간 직접 참조를 금지하는 규칙을 세워 '언제든지 떼어낼 수 있는' 구조를 만들었습니다."
          },
          {
            "title": "테스트 주도 개발(TDD)의 필요성 체감",
            "content": "복잡한 투자 전략 로직(골든크로스, 손절매, 레버리지 계산)은 눈으로만 검증하기 어렵습니다. pytest를 도입하여 주요 지표 계산 로직과 주문 실행 로직에 대한 단위 테스트를 작성했습니다. 엣지 케이스(데이터 누락, 0으로 나누기 등)에 대한 테스트 케이스를 미리 작성함으로써 배포 후 발생할 수 있는 치명적인 버그를 사전에 차단할 수 있었습니다."
          },
          {
            "title": "비동기 처리에 대한 깊은 이해",
            "content": "CPU-bound와 I/O-bound 작업의 특성을 이해하고 물리적으로 격리하는 것이 시스템 안정성의 핵심임을 배웠습니다. 단순히 async/await를 사용하는 것이 아닌, 워커 분리와 메시지 큐를 통한 진정한 비동기 아키텍처를 구축했습니다."
          }
        ]
      },
      "color": "#ff6b35"
    },
    {
      "id": "skill-celery",
      "type": "skill",
      "label": "Celery",
      "connections": ["project-cortex"],
      "details": {
        "description": "분산 태스크 큐 시스템으로, CPU-bound와 I/O-bound 작업을 비동기로 처리합니다."
      },
      "color": "#37814a"
    },
    {
      "id": "skill-redis",
      "type": "skill",
      "label": "Redis",
      "connections": ["project-cortex"],
      "details": {
        "description": "인메모리 데이터 저장소로, Message Broker 및 Pub/Sub 기반 실시간 통신에 활용됩니다."
      },
      "color": "#dc382d"
    },
    {
      "id": "skill-timescaledb",
      "type": "skill",
      "label": "TimescaleDB",
      "connections": ["project-cortex"],
      "details": {
        "description": "PostgreSQL 기반의 시계열 데이터베이스로, 대용량 OHLCV 데이터 처리에 최적화되어 있습니다."
      },
      "color": "#fdb515"
    },
    {
      "id": "skill-docker",
      "type": "skill",
      "label": "Docker",
      "connections": ["project-cortex"],
      "details": {
        "description": "컨테이너 기반의 애플리케이션 배포 및 환경 일관성을 보장합니다."
      },
      "color": "#2496ed"
    },
    {
      "id": "skill-postgresql",
      "type": "skill",
      "label": "PostgreSQL",
      "connections": ["project-cortex"],
      "details": {
        "description": "관계형 데이터베이스로, 사용자/전략/백테스트 데이터 저장 및 Optuna Study 공유 저장소로 활용됩니다."
      },
      "color": "#336791"
    },
    {
      "id": "project-cortex-fe",
      "type": "project",
      "label": "Cortex-Frontend",
      "connections": [
        "me",
        "project-cortex",
        "skill-nextjs",
        "skill-typescript",
        "skill-tailwind",
        "skill-zustand",
        "skill-react-query",
        "skill-recharts",
        "skill-websocket"
      ],
      "details": {
        "description": "개인 투자자가 코딩 없이 투자 전략을 설계하고, 백테스팅 검증 후 자동매매까지 연결하는 올인원 퀀트 플랫폼의 프론트엔드입니다. 복잡한 알고리즘 투자를 직관적인 UI로 풀어내는 것을 목표로, 아토믹 디자인 패턴 기반의 컴포넌트 시스템과 대용량 금융 데이터 시각화, 실시간 웹소켓 처리를 구현했습니다.",
        "technologies": [
          "Next.js 14 (App Router)",
          "TypeScript 5",
          "Tailwind CSS",
          "Zustand + Immer",
          "TanStack Query v5",
          "React Hook Form + Zod",
          "Lightweight Charts",
          "Recharts",
          "WebSocket"
        ],
        "coreFeatures": [
          "� No-Code 전략 빌더 (재귀적 AND/OR 로직 시각화)",
          "� 인터랙티브 백테스팅 결과 시각화",
          "⚡ 실시간 최적화 모니터링 대시보드",
          "🔐 Silent Auth Refresh (무중단 인증)",
          "� Dark Mode First 디자인 시스템"
        ],
        "techStackDocs": [
          {
            "name": "Next.js 14 (App Router)",
            "description": "SEO 최적화 및 React Server Components를 활용한 초기 로딩 속도 개선. DDD 구조로 기능별 폴더를 격리하고 (authenticated) 라우트 그룹으로 유지보수성 향상."
          },
          {
            "name": "TypeScript",
            "description": "엄격한 타입 지정으로 런타임 에러 방지. 백엔드 API 응답값을 schema.d.ts로 정의하여 프론트-백엔드 간 의사소통 비용 절감."
          },
          {
            "name": "Zustand + Immer",
            "description": "전략 빌더의 깊은 중첩 객체 상태를 불변성 유지하며 업데이트. Redux 대비 코드량 70% 감축."
          },
          {
            "name": "TanStack Query",
            "description": "서버 데이터 캐싱 및 중복 호출 방지. staleTime, cacheTime 조절로 불필요한 API 호출 최소화."
          },
          {
            "name": "React Hook Form + Zod",
            "description": "복잡한 전략 설정 폼의 렌더링 최적화 및 스키마 기반 유효성 검사."
          },
          {
            "name": "Lightweight Charts",
            "description": "TradingView 기반의 고성능 캔버스 차트로 수만 개의 캔들 데이터 렌더링 최적화."
          }
        ],
        "codeExamples": [
          {
            "title": "재귀 컴포넌트 패턴 (Recursive Component)",
            "category": "architecture",
            "description": "개발자만 알던 if-else 로직을 사용자가 이해할 수 있는 시각적 블록으로 변환. Atomic Updates로 트리 전체가 아닌 타겟 노드만 정밀 업데이트.",
            "filePath": "frontend/src/components/domain/strategy/StrategyBuilderCanvas.tsx",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/frontend/src/components/domain/strategy/StrategyBuilderCanvas.tsx",
            "snippet": "function RecursiveRuleRenderer({ items }) {\n  return (\n    <div className=\"space-y-4\">\n      {items.map((item) => (\n        <div key={item.id} className=\"relative\">\n          <RuleBlock item={item} />\n          {item.children && (\n             // 자식 조건이 있을 경우 자기 자신을 다시 렌더링\n             <div className=\"pl-8 border-l-2\">\n               <RecursiveRuleRenderer items={item.children} />\n             </div>\n          )}\n        </div>\n      ))}\n    </div>\n  );\n}"
          },
          {
            "title": "무중단 토큰 갱신 (Silent Refresh)",
            "category": "auth",
            "description": "401 발생 시 Lock & Queue 시스템으로 토큰 갱신 트래픽을 1/N로 감소. 사용자는 토큰 만료를 인지하지 못하고 끊김 없는 서비스 이용.",
            "filePath": "frontend/src/lib/apiClient.ts",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/frontend/src/lib/apiClient.ts",
            "snippet": "apiClient.interceptors.response.use(\n  (response) => response,\n  async (error) => {\n    const originalRequest = error.config;\n    if (error.response?.status === 401 && !originalRequest._retry) {\n      originalRequest._retry = true;\n      // Lock: 첫 번째 401만 갱신 시도\n      if (!isRefreshing) {\n        isRefreshing = true;\n        const newToken = await refreshToken();\n        // Queue에 대기 중인 요청들 일괄 재시도\n        processQueue(newToken);\n      }\n      // 현재 요청을 Queue에 추가\n      return new Promise((resolve) => {\n        failedQueue.push({ resolve, config: originalRequest });\n      });\n    }\n    return Promise.reject(error);\n  }\n);"
          },
          {
            "title": "명령형 차트 업데이트 (Imperative Update)",
            "category": "performance",
            "description": "차트 데이터를 React State가 아닌 useRef로 관리. 리렌더링 없이 series.setData 직접 호출로 차트 로딩 시간 50% 단축.",
            "filePath": "frontend/src/hooks/useChartIndicatorManager.ts",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/frontend/src/hooks/useChartIndicatorManager.ts",
            "snippet": "// useChartIndicatorManager.ts\nconst chartRef = useRef<IChartApi | null>(null);\nconst seriesRef = useRef<ISeriesApi<'Candlestick'> | null>(null);\n\nuseEffect(() => {\n  if (data && seriesRef.current) {\n    // React State 없이 차트 인스턴스 직접 업데이트\n    seriesRef.current.setData(data);\n  }\n}, [data]);\n\n// Cleanup: 메모리 누수 방지\nuseEffect(() => {\n  return () => chartRef.current?.remove();\n}, []);"
          },
          {
            "title": "WebSocket 캐시 동기화 (Query Cache Sync)",
            "category": "realtime",
            "description": "소켓 메시지 Payload로 캐시를 직접 수정(Mutable-like)하여 API 요청 없이 UI 즉시 갱신. 네트워크 트래픽 획기적 감소.",
            "filePath": "frontend/src/components/domain/backtesting/BacktestContent.tsx",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/frontend/src/components/domain/backtesting/BacktestContent.tsx",
            "snippet": "ws.onmessage = (event) => {\n  const message = JSON.parse(event.data);\n  // API 재호출 없이 캐시 직접 수정\n  queryClient.setQueryData(['backtestCore', id], (old) => ({\n    ...old,\n    progress: message.progress,\n    status: message.status,\n  }));\n  // 완료 시에만 전체 데이터 리페칭\n  if (message.status === 'completed') {\n    queryClient.invalidateQueries(['backtestCore', id]);\n  }\n};"
          }
        ],
        "link": "https://github.com/sleepyMS/Cortex",
        "features": [
          {
            "title": "인터랙티브 백테스팅 결과 시각화",
            "items": [
              "수년치 OHLCV 데이터와 백테스팅 매매 시점, 보조지표를 캔들스틱 차트에 렌더링",
              "DynamicStrategyChart 컴포넌트로 매수/매도 마커 시각화",
              "WebSocket을 통한 실시간 진행률 표시"
            ]
          },
          {
            "title": "노코드(No-Code) 전략 빌더",
            "items": [
              "드래그 앤 드롭이나 UI 조작만으로 복잡한 매매 로직(AND/OR 조건, 지표 크로스) 생성",
              "OptimizationParameterTreeView로 중첩 JSON 구조를 직관적인 Tree UI로 변환",
              "Zustand의 findAndModify 유틸리티로 타겟 노드만 정밀 업데이트"
            ]
          },
          {
            "title": "실시간 최적화 모니터링 대시보드",
            "items": [
              "대규모 연산이 필요한 전략 최적화 과정의 진행 상황과 중간 결과를 실시간 확인",
              "ParallelCoordinatesChart로 수천 번의 Trial 결과를 다차원 시각화",
              "ParameterImportanceChart로 파라미터 간 상관관계 분석"
            ]
          },
          {
            "title": "하이브리드 차트 시스템",
            "items": [
              "메인 시세 차트는 Canvas(Lightweight-charts), 포트폴리오 분석은 SVG(Recharts)로 이원화",
              "next/dynamic으로 차트 라이브러리(~150kb) 지연 로딩하여 초기 번들 사이즈(FCP) 최적화",
              "useChartIndicatorManager 훅으로 차트 인스턴스 생성/업데이트/메모리 해제 캡슐화"
            ]
          },
          {
            "title": "아토믹 디자인 기반 컴포넌트 아키텍처",
            "items": [
              "src/components/ui/ - 버튼, 인풋 등 가장 작은 단위(Design System)",
              "src/components/layout/ - 헤더, 사이드바 등 페이지 골격",
              "src/components/domain/ - 비즈니스 로직 포함 복합 컴포넌트(StrategyBuilder 등)",
              "src/providers/ - QueryClient, Theme 등 전역 설정 주입"
            ]
          },
          {
            "title": "서버 상태와 클라이언트 상태의 분리",
            "items": [
              "데이터의 출처와 성격에 따라 상태 관리 도구를 이원화하여 복잡도를 낮웄",
              "Server State (TanStack Query): API 데이터(백테스트 결과, 유저 정보). staleTime, cacheTime 조절로 불필요한 API 호출 최소화",
              "Client State (Zustand): UI 상태(다크모드 토글, 사이드바 열림/닫힘)"
            ]
          }
        ],
        "optimizations": [
          {
            "title": "대용량 차트 데이터 렌더링 최적화",
            "items": [
              "Imperative Update: 차트 데이터를 React State가 아닌 useRef로 관리하여 불필요한 리렌더링 방지",
              "series.setData 직접 호출로 DOM 업데이트 최소화",
              "성과: 차트 로딩 시간 50% 단축, 스크롤 시 FPS 60 유지"
            ]
          },
          {
            "title": "중첩 폼 성능 개선",
            "items": [
              "React Hook Form의 useFieldArray로 동적 필드 추가/삭제 로직 최적화",
              "Component Isolation: 입력 컴포넌트 분리 후 React.memo 적용으로 변경된 필드만 리렌더링",
              "성과: 조건 블록 50개 이상에서도 타이핑 지연 없음"
            ]
          },
          {
            "title": "병렬 데이터 페칭",
            "items": [
              "백테스팅 상세 페이지에서 [핵심 정보], [차트 데이터], [거래 로그] 3개 API 동시 호출",
              "각 로딩 상태 분리로 차트 로딩 중에도 핵심 정보 즉시 표시 (Blocking 방지)"
            ]
          },
          {
            "title": "Skeleton UI & Suspense 적용",
            "items": [
              "데이터 의존성이 높은 대시보드 특성상 로딩 중 레이아웃 무너짐 방지",
              "컴포넌트 단위의 스켈레톤 UI로 사용자 체감 성능 향상",
              "Optimistic Update로 서버 응답 전 UI 선반영"
            ]
          },
          {
            "title": "Dark Mode First 디자인",
            "items": [
              "장시간 차트를 보는 트레이더의 눈 피로도를 고려하여 다크 모드 기본 설계",
              "Tailwind CSS의 dark: 클래스를 활용한 테마 스위칭 구현"
            ]
          }
        ],
        "challenges": [
          {
            "title": "대용량 차트 데이터 렌더링 시 UI 프리징",
            "problem": "수만 개의 캔들 데이터와 지표를 React State로 관리하니 브라우저 메모리 급증 및 UI 버벅거림. 차트 라이브러리 객체가 React 라이프사이클과 맞지 않게 재생성됨.",
            "solution": "Imperative Update 패턴 도입. 차트 데이터는 useRef로 관리하고 series.setData 직접 호출. useChartIndicatorManager 훅으로 생성/업데이트/cleanup 로직 캡슐화."
          },
          {
            "title": "JWT 토큰 만료 시 경쟁 상태 (Race Condition)",
            "problem": "대시보드 진입 시 5개 API 동시 호출 중 토큰 만료 시 5번의 401 에러와 5번의 Refresh 요청 발생. 서버가 토큰 탈취로 간주하여 로그아웃 처리.",
            "solution": "Axios Interceptor에 Lock & Queue 시스템 도입. 첫 401에서 isRefreshing 플래그 설정, 이후 요청은 failedQueue에 대기. 토큰 갱신 후 일괄 재시도하여 트래픽 1/N 감소."
          },
          {
            "title": "복잡한 중첩 폼의 성능 저하",
            "problem": "전략 빌더에서 조건 블록이 많아질수록 텍스트 입력 시 전체 폼 리렌더링으로 타이핑 딜레이 발생.",
            "solution": "useFieldArray로 동적 필드 최적화. 입력 컴포넌트 분리 후 memo 적용으로 변경 필드만 리렌더링. 50개 이상 블록에서도 지연 없음."
          },
          {
            "title": "폼 상태와 전역 상태의 비동기화",
            "problem": "React Hook Form의 빠른 타이핑을 Zustand가 따라가지 못해 저장 시 구버전 데이터 전송. Two Sources of Truth 문제.",
            "solution": "역할 분리(Separation of Concerns). 입력은 로컬 상태(useForm)에 위임하고, 저장 시점에만 handleSubmit으로 Zustand에 업데이트하는 단방향 데이터 흐름으로 구조 변경."
          }
        ],
        "learnings": [
          {
            "title": "TypeScript의 가치",
            "content": "백엔드 API 응답값을 schema.d.ts로 정의하고 공유함으로써, 프론트-백엔드 간 의사소통 비용을 줄이고 undefined 참조 오류를 사전에 방지할 수 있었습니다."
          },
          {
            "title": "DOM 조작 라이브러리와 React의 공존",
            "content": "Lightweight Charts처럼 DOM을 직접 조작하는 라이브러리와 Virtual DOM 기반의 React 사이 괴리를 useRef와 useEffect 생명주기 관리로 해결하며 렌더링 성능 최적화 노하우를 쌓았습니다."
          },
          {
            "title": "UX 중심 설계의 중요성",
            "content": "단순 기능 구현에 그치지 않고, 복잡한 퀀트 데이터를 사용자가 쉽게 이해할 수 있도록 Skeleton UI와 Optimistic Update를 적용하여 체감 성능 2배 이상 향상을 달성했습니다."
          },
          {
            "title": "추상화의 역설",
            "content": "모든 로직을 커스텀 훅으로 분리하려다 오히려 코드 추적이 어려워지는 경험을 했습니다. '재사용성'보다 '응집도(Cohesion)'를 우선하여 도메인 종속 로직은 컴포넌트 내부에 배치하는 실용적 설계를 배웠습니다."
          }
        ]
      },
      "color": "#3b82f6"
    },
    {
      "id": "skill-nextjs",
      "type": "skill",
      "label": "Next.js",
      "connections": ["project-cortex-fe"],
      "details": {
        "description": "React 기반의 풀스택 프레임워크로, App Router와 서버 컴포넌트를 활용한 최적화된 웹 애플리케이션 개발에 사용됩니다."
      },
      "color": "#000000"
    },
    {
      "id": "skill-react-query",
      "type": "skill",
      "label": "TanStack Query",
      "connections": ["project-cortex-fe"],
      "details": {
        "description": "서버 상태 관리 라이브러리로, 비동기 데이터 페칭, 캐싱, 동기화를 효율적으로 처리합니다."
      },
      "color": "#ff4154"
    },
    {
      "id": "skill-recharts",
      "type": "skill",
      "label": "Recharts",
      "connections": ["project-cortex-fe"],
      "details": {
        "description": "React 기반 차트 라이브러리로, 재사용 가능한 차트 컴포넌트를 제공합니다."
      },
      "color": "#22b5bf"
    },
    {
      "id": "skill-websocket",
      "type": "skill",
      "label": "WebSocket",
      "connections": ["project-cortex-fe"],
      "details": {
        "description": "양방향 실시간 통신 프로토콜로, 백테스팅 진행률 등 실시간 UI 업데이트에 활용됩니다."
      },
      "color": "#010101"
    },
    {
      "id": "project-paper-lstm",
      "type": "project",
      "label": "LSTM_암호화폐_논문-AI",
      "connections": ["me", "skill-python", "skill-lstm", "skill-tensorflow"],
      "details": {
        "description": "KCI 등재 학술논문으로, LSTM 기반 고가·저가 예측 모델을 활용한 암호화폐 선물거래 시스템을 연구했습니다. 기존 종가 기반 예측 모델 대신 고가/저가 데이터를 활용하여 선물거래에서 실질적인 수익률 개선을 달성했습니다.",
        "technologies": [
          "Python",
          "TensorFlow/Keras",
          "LSTM",
          "Pandas",
          "NumPy",
          "Matplotlib"
        ],
        "coreFeatures": [
          "📊 고가·저가 기반 LSTM 예측 모델",
          "💹 암호화폐 선물거래 시스템 (롱/숏 포지션)",
          "� 평균 +28.3% 수익률 개선 (ETH/XRP/DOGE)",
          "🎯 DOGE 최대 +45.96% 수익률 향상"
        ],
        "techStackDocs": [
          {
            "name": "LSTM (Long Short-Term Memory)",
            "description": "RNN의 장기 의존성 문제를 해결하고, 노이즈가 많은 금융 시계열 데이터에서도 안정적이고 일관된 예측 성능을 보이는 딥러닝 모델."
          },
          {
            "name": "TensorFlow 2.15 / Keras 2.15",
            "description": "Google Colab 환경에서 LSTM 모델 구현 및 학습에 사용. Adam 옵티마이저(lr=0.001)와 MSE 손실 함수 적용."
          },
          {
            "name": "MinMaxScaler",
            "description": "시계열 데이터 정규화를 위한 스케일링 처리. 타임스탬프 길이 14로 데이터 전처리."
          }
        ],
        "link": "https://www.kci.go.kr/kciportal/ci/sereArticleSearch/ciSereArtiView.kci?sereArticleSearchBean.artiId=ART003239433",
        "features": [
          {
            "title": "데이터 수집 및 전처리",
            "items": [
              "바이낸스 거래소 데이터 (TradingView 추출)",
              "대상: ETH, XRP, DOGE (BTC 추종 주요 알트코인)",
              "기간: 2022.02.01 ~ 2023.12.31 (약 2년)",
              "타임스탬프 길이 14, MinMaxScaler 정규화",
              "데이터 분할: 훈련 60% / 검증 20% / 테스트 20%"
            ]
          },
          {
            "title": "LSTM 모델 아키텍처",
            "items": [
              "환경: Google Colab + Python 3.10 + TensorFlow 2.15",
              "LSTM 레이어 2개 (256 → 128 유닛) + Dense 2개 (64 → 1 유닛)",
              "Dropout 0.05 적용, Adam 옵티마이저 (lr=0.001)",
              "손실 함수: MSE, 배치 크기 32, 에포크 100"
            ]
          },
          {
            "title": "선물거래 수익률 계산 시스템",
            "items": [
              "롱 포지션: 예측가 < 당일 고가 → 예측가에서 청산",
              "숏 포지션: 예측가 > 당일 저가 → 예측가에서 청산",
              "일별 Stop-Loss: 예측가 미도달 시 당일 종가로 청산",
              "매일 새 포지션 설정으로 시장 상황 대응"
            ]
          },
          {
            "title": "정량적 성과 비교",
            "items": [
              "ETH: Pearson 0.973→0.946, 승률 80.1%→77.9%, 수익률 +6.27%",
              "XRP: Pearson 0.962→0.914, 승률 72.2%→69.5%, 수익률 +32.71%",
              "DOGE: Pearson 0.969→0.930, 승률 75.1%→73.6%, 수익률 +45.96%",
              "특이점: DOGE 종가 모델 -13.19% → 고가/저가 모델 +32.77%"
            ]
          }
        ],
        "optimizations": [
          {
            "title": "선물거래 특화 타겟 설계",
            "items": [
              "가격 상승일: 고가(High)를 예측 타겟으로 설정",
              "가격 하락일: 저가(Low)를 예측 타겟으로 설정",
              "기존 종가 예측과 달리 변동 범위를 예측하여 수익 극대화"
            ]
          },
          {
            "title": "과적합 방지 기법",
            "items": [
              "EarlyStopping: 검증 손실 10에포크 미개선 시 훈련 중단",
              "최적 가중치 자동 복원 (restore_best_weights)",
              "Dropout 0.05로 LSTM 레이어 정규화"
            ]
          },
          {
            "title": "24시간 시장 특성 반영",
            "items": [
              "암호화폐 시장 연중무휴 특성 고려",
              "일별 단위 포지션으로 빠른 변동성 대응",
              "급격한 가격 변동을 고가/저가 피쳐로 포착"
            ]
          }
        ],
        "challenges": [
          {
            "title": "Transformer vs LSTM 모델 선택",
            "problem": "TFT, FEDformer 등 최신 Transformer 모델이 다중 피쳐 통합에 강점을 보이지만, 결과의 변동성이 크고 노이즈에 취약함. 암호화폐처럼 피쳐가 단순(OHLC)하고 노이즈가 극단적인 환경에서 적합한지 의문.",
            "solution": "Bilokon & Qiu (2023) 연구를 참고하여, 단순 피쳐 + 고변동성 환경에서는 LSTM의 반복적 기억 구조가 과적합 없이 더 안정적으로 작동함을 확인. 복잡성 최소화와 안정성을 동시에 추구."
          },
          {
            "title": "예측 정확도 vs 실제 수익률 괴리",
            "problem": "고가/저가 기반 모델은 Pearson 상관계수와 승률이 종가 기반 모델보다 낮음 (예: ETH 0.973→0.946). 전통적인 예측 성능 지표로는 모델의 실효성을 판단하기 어려움.",
            "solution": "선물거래의 본질인 '수익률'을 핵심 평가 지표로 설정. 상관계수/승률이 낮더라도 실제 수익률이 높으면 유효한 모델로 판단. DOGE에서 종가 모델 -13.19% vs 고가/저가 모델 +32.77%로 검증."
          },
          {
            "title": "데이터 복잡성과 모델 성능 트레이드오프",
            "problem": "고가/저가를 동시에 예측하면 데이터 복잡성이 증가하여 예측 정확도가 일부 하락함.",
            "solution": "선물거래에서는 정확한 방향 예측보다 가격 범위 예측이 더 중요함을 실험으로 입증. 수익률 관점에서 복잡성 증가가 오히려 이점으로 작용."
          }
        ],
        "learnings": [
          {
            "title": "왜 Transformer가 아닌 LSTM인가",
            "content": "Bilokon & Qiu (2023)의 'Transformers versus LSTMs for electronic trading' 연구에 따르면, 단순한 OHLC 피쳐와 높은 변동성 환경에서는 Transformer의 복잡한 Attention보다 LSTM의 반복적 기억 구조가 과적합 없이 더 견고하게 작동합니다."
          },
          {
            "title": "예측 성능 ≠ 수익 성능",
            "content": "Pearson 상관계수와 승률이 높다고 실제 수익률이 높은 것은 아닙니다. 선물거래의 특성(롱/숏 레버리지)을 반영한 수익률 지표로 모델을 평가해야 실질적인 성과를 측정할 수 있습니다."
          },
          {
            "title": "도메인 지식이 피쳐 설계를 결정",
            "content": "선물거래에서 롱/숏 포지션의 수익 구조를 이해하고, 이에 맞게 고가/저가 데이터를 예측 타겟으로 설정한 것이 기존 종가 예측 연구와의 핵심 차별점입니다."
          },
          {
            "title": "변동성이 클수록 효과가 큼",
            "content": "상대적으로 변동성이 낮은 ETH는 +6.27%, 중간인 XRP는 +32.71%, 고변동성인 DOGE는 +45.96%의 수익률 개선을 보였습니다. 고가/저가 접근법은 특히 고변동성 자산에서 효과적입니다."
          },
          {
            "title": "향후 연구 방향",
            "content": "TFT, FEDformer, PatchTST, TimesNet 등 최신 시계열 알고리즘 비교, SHAP 분석과 Attention 가중치 시각화를 통한 피쳐 중요도 분석, 뉴스/소셜미디어 감성 분석 통합 등으로 확장 가능합니다."
          }
        ],
        "references": [
          {
            "id": 1,
            "title": "Crypto-assets: Economic Nature, Classification and Regulation of Turnover",
            "authors": "D. Kochergin",
            "year": "2022",
            "source": "Int. Organ. Res. J., Vol. 17, No. 3, pp. 75-113"
          },
          {
            "id": 2,
            "title": "The Cross-section of Crypto-currencies as Financial Assets: An Overview",
            "authors": "H. Elendner, S. Trimborn, B. Ong, T. M. Lee",
            "year": "2016",
            "source": "SFB 649 Discussion Paper"
          },
          {
            "id": 3,
            "title": "Automation and Machine Learning in Transforming the Financial Industry",
            "authors": "P. K. Donepudi",
            "year": "2019",
            "source": "Asian Business Review, Vol. 9, No. 3, pp. 129-138"
          },
          {
            "id": 4,
            "title": "Artificial Intelligence Driven Crypto Currencies",
            "authors": "A. Ganapathy, M. Redwanuzzaman, M. M. Rahaman, W. Khan",
            "year": "2020",
            "source": "Global Disclosure of Economics and Business, Vol. 9, No. 2, pp. 107-118"
          },
          {
            "id": 5,
            "title": "A Deep Reinforcement Learning Approach for Automated Cryptocurrency Trading",
            "authors": "G. Lucarelli and M. Borrotti",
            "year": "2019",
            "source": "Proc. of AIAI 2019, pp. 247-258"
          },
          {
            "id": 6,
            "title": "Understanding LSTM—A Tutorial into Long Short-term Memory Recurrent Neural Networks",
            "authors": "R. C. Staudemeyer and E. R. Morris",
            "year": "2019",
            "source": "arXiv:1909.09586"
          },
          {
            "id": 7,
            "title": "Time Series Analysis of Cryptocurrency Prices Using Long Short-term Memory",
            "authors": "J. P. Fleischer, G. von Laszewski, C. Theran, Y. J. Parra Bautista",
            "year": "2022",
            "source": "Algorithms, Vol. 15, No. 7, p. 230"
          },
          {
            "id": 8,
            "title": "Transformers versus LSTMs for electronic trading",
            "authors": "P. Bilokon and Y. Qiu",
            "year": "2023",
            "source": "arXiv:2309.11400"
          },
          {
            "id": 9,
            "title": "Forecasting Cryptocurrency Prices Using LSTM, GRU, and Bi-directional LSTM: A Deep Learning Approach",
            "authors": "P. L. Seabe, C. R. B. Moutsinga, E. Pindza",
            "year": "2023",
            "source": "Fractal and Fractional, Vol. 7, No. 2, p. 203"
          },
          {
            "id": 10,
            "title": "A Novel Cryptocurrency Price Prediction Model Using GRU, LSTM and Bi-LSTM Machine Learning Algorithms",
            "authors": "M. J. Hamayel and A. Y. Owda",
            "year": "2021",
            "source": "AI, Vol. 2, No. 4, pp. 477-496"
          },
          {
            "id": 11,
            "title": "Enhancing Price Prediction in Cryptocurrency Using Transformer Neural Network and Technical Indicators",
            "authors": "M. A. L. Khaniki and M. Manthouri",
            "year": "2024",
            "source": "arXiv:2403.03606"
          },
          {
            "id": 12,
            "title": "LSTM Based Sentiment Analysis for Cryptocurrency Prediction",
            "authors": "X. Huang et al.",
            "year": "2021",
            "source": "Proc. of DASFAA 2021, pp. 617-621"
          },
          {
            "id": 13,
            "title": "Forecasting Directional Bitcoin Price Returns Using Aspect-based Sentiment Analysis on Online Text Data",
            "authors": "E. Loginova et al.",
            "year": "2024",
            "source": "Machine Learning, Vol. 113, No. 7, pp. 4761-4784"
          },
          {
            "id": 14,
            "title": "Sentiment-driven Price Prediction of the Bitcoin Based on Statistical and Deep Learning Approaches",
            "authors": "G. Serafini et al.",
            "year": "2020",
            "source": "Proc. of IJCNN 2020, pp. 1-8"
          },
          {
            "id": 15,
            "title": "Algorithmic Trading of Cryptocurrency Based on Twitter Sentiment Analysis",
            "authors": "S. Colianni, S. Rosales, M. Signorotti",
            "year": "2015",
            "source": "CS229 Project, Vol. 1, No. 5, pp. 1-4"
          },
          {
            "id": 16,
            "title": "Price Movement Prediction of Cryptocurrencies Using Sentiment Analysis and Machine Learning",
            "authors": "F. Valencia, A. Gómez-Espinosa, B. Valdés-Aguirre",
            "year": "2019",
            "source": "Entropy, Vol. 21, No. 6, p. 589"
          },
          {
            "id": 17,
            "title": "Sentiment Analysis of News for Effective Cryptocurrency Price Prediction",
            "authors": "A.-D. Vo, Q.-P. Nguyen, C.-Y. Ock",
            "year": "2019",
            "source": "Int. J. Knowl. Eng., Vol. 5, No. 2, pp. 47-52"
          },
          {
            "id": 18,
            "title": "Breaking News Headlines: Impact on Trading Activity in the Cryptocurrency Market",
            "authors": "A. K. Kulbhaskar and S. Subramaniam",
            "year": "2023",
            "source": "Econ. Model., Vol. 126, p. 106397"
          },
          {
            "id": 19,
            "title": "Investigating the Informativeness of Technical Indicators and News Sentiment in Financial Market Price Prediction",
            "authors": "S. A. Farimani et al.",
            "year": "2022",
            "source": "Knowl.-Based Syst., Vol. 247, p. 108742"
          },
          {
            "id": 20,
            "title": "Bitcoin Futures—What Use Are They?",
            "authors": "S. Corbet, B. Lucey, M. Peat, S. Vigne",
            "year": "2018",
            "source": "Econ. Lett., Vol. 172, pp. 23-27"
          },
          {
            "id": 21,
            "title": "The Impacts of Futures Trading on Volatility and Volatility Asymmetry of Bitcoin Returns",
            "authors": "C. Zhang, H. Ma, G. B. Arkorful, Z. Peng",
            "year": "2023",
            "source": "Int. Rev. Financ. Anal., Vol. 86, p. 102497"
          }
        ],
        "pdfLink": "/pdf/LSTM_Cryptocurrency_Future_Prediction_Model.pdf",
        "image": "/images/lstm/Deep_learning_architecture_flow_chart.png",
        "performance": [
          {
            "title": "알트코인 데이터 유형별 예측 성능 비교",
            "description": "기존 종가 기반 모델(Basic)과 제안된 고가/저가 기반 모델(Improved)의 예측 성능 비교입니다. 고가/저가 모델은 변동성 예측에 집중하여 상관계수와 승률은 소폭 낮지만, 실제 수익률 개선에 기여합니다.",
            "headers": ["Altcoin", "Model", "Pearson Correlation", "Win Rate"],
            "rows": [
              ["ETH", "Basic Data", "0.973", "80.1%"],
              ["ETH", "Improved Data", "0.946", "77.9%"],
              ["XRP", "Basic Data", "0.962", "72.2%"],
              ["XRP", "Improved Data", "0.914", "69.5%"],
              ["DOGE", "Basic Data", "0.969", "75.1%"],
              ["DOGE", "Improved Data", "0.930", "73.6%"]
            ]
          },
          {
            "title": "알트코인 데이터 유형별 수익률 비교",
            "description": "제안된 고가/저가 모델(Improved Data)이 기존 모델 대비 모든 코인에서 더 높은 수익률을 기록했습니다. 특히 변동성이 큰 DOGE, XRP에서 큰 폭의 개선을 보였습니다.",
            "headers": [
              "Altcoin",
              "Basic Data Profit",
              "Improved Data Profit",
              "Gain"
            ],
            "rows": [
              ["ETH", "30.78%", "37.05%", "+6.27%"],
              ["XRP", "64.78%", "97.49%", "+32.71%"],
              ["DOGE", "-13.19%", "32.77%", "+45.96%"]
            ]
          },
          {
            "title": "DOGE 가격 예측 결과 분석",
            "description": "종가 데이터 기반(a)은 실제와 유사하지만, 고가/저가 데이터 기반(b)이 변동성을 더 잘 반영하여 수익률이 높음.",
            "image": "/images/lstm/DOGE_Price_Prediction_Results.png"
          },
          {
            "title": "데이터 전처리 과정",
            "description": "MinMaxScaler 스케일링 및 60:20:20 데이터 분할 전략.",
            "image": "/images/lstm/Data_preprocessing.png"
          }
        ]
      },
      "color": "#10b981"
    },
    {
      "id": "project-paper-tft",
      "type": "project",
      "label": "Dual-Stream_TFT_논문-AI",
      "connections": [
        "me",
        "skill-python",
        "skill-transformer",
        "skill-pytorch"
      ],
      "details": {
        "description": "일본 오사카 리츠메이칸 대학교 컨퍼런스에서 발표한 논문으로, Dual-Stream Temporal Fusion Transformer를 활용한 암호화폐 가격 예측 시스템을 연구했습니다. 가격 지표와 감성 데이터를 분리된 스트림으로 처리하고 동적 게이팅 메커니즘으로 융합하여 일반화 성능과 모델 해석력을 동시에 개선했습니다.",
        "technologies": [
          "Python 3.10",
          "PyTorch 2.1.0",
          "Lightning 2.5.1",
          "Temporal Fusion Transformer",
          "Optuna",
          "CUDA 11.8"
        ],
        "coreFeatures": [
          "🔀 Dual-Stream 아키텍처 설계",
          "📊 가격 + 감성 데이터 독립 처리",
          "🎯 MAE 2.31% 개선 / RMSE 2.28% 개선 / Vol 1.31% 개선",
          "🔍 Attention 기반 해석 가능성"
        ],
        "techStackDocs": [
          {
            "name": "Temporal Fusion Transformer (TFT)",
            "description": "Variable Selection Network와 Gating 메커니즘을 통해 불필요한 피쳐를 억제하고 중요 변수를 강조하는 해석 가능한 시계열 예측 모델."
          },
          {
            "name": "PyTorch + Lightning",
            "description": "PyTorch 2.1.0과 Lightning 2.5.1을 사용한 딥러닝 모델 구현. CUDA 11.8 GPU 가속 활용."
          },
          {
            "name": "Optuna",
            "description": "자동화된 하이퍼파라미터 탐색을 위한 프레임워크. 배치 크기, hidden size, dropout, learning rate 최적화."
          }
        ],
        "features": [
          {
            "title": "데이터 수집 및 전처리",
            "items": [
              "BTC OHLCV 데이터: Binance API (시간 단위)",
              "소셜 감성 점수: Santiment API (sentiment_balance_total, soc_sr)",
              "뉴스 감성 점수: Alpha Vantage API (ticker_sentiment_score, news_sr)",
              "기술 지표: MA, RSI 계산",
              "뉴스 감성에 4시간 반감기 지수 감쇠 적용",
              "데이터 분할: 훈련 70% / 검증 15% / 테스트 15%"
            ]
          },
          {
            "title": "Dual-Stream TFT 아키텍처",
            "items": [
              "Price Stream: BTC 가격 데이터 + 기술 지표 (MA, RSI)",
              "Sentiment Stream: 소셜 감성 + 뉴스 감성 + 변화율",
              "각 스트림별 독립 TFT 인코더",
              "Gated Fusion: α = σ(gate([yp, ys])), ŷ = α·yp + (1-α)·ys"
            ]
          },
          {
            "title": "정량적 성과 비교",
            "items": [
              "Validation: MAE 320.78 (+0.47%), RMSE 484.13 (-0.24%)",
              "Test: MAE 350.01 (-2.31%), RMSE 555.69 (-2.28%)",
              "예측 변동성 1.31% 감소로 안정성 향상",
              "Single-stream 대비 일반화 성능 개선 확인"
            ]
          },
          {
            "title": "Attention 분석 결과",
            "items": [
              "Price Stream: 후반 타임스텝(15-23)으로 점진적 집중",
              "Sentiment Stream: 10, 17, 21 타임스텝에서 sharp peak",
              "두 스트림 간 차별화된 시간적 패턴 확인",
              "모델 해석 가능성 향상"
            ]
          }
        ],
        "optimizations": [
          {
            "title": "동적 게이팅 메커니즘",
            "items": [
              "가격/감성 스트림 출력을 concat 후 gating layer 적용",
              "각 타임스텝별 스트림 기여도 가중치 학습",
              "해석 가능성: 게이트 가중치로 스트림 중요도 시각화"
            ]
          },
          {
            "title": "하이퍼파라미터 최적화",
            "items": [
              "Optuna 기반 자동 탐색",
              "배치 크기, hidden size, dropout, learning rate 최적화",
              "시나리오별 독립적 최적화 수행"
            ]
          },
          {
            "title": "감성 데이터 전처리",
            "items": [
              "뉴스 감성에 반감기 지수 감쇠 적용 (4시간)",
              "감성 부재 구간 명시적 0값 유지",
              "1차 변화율(sr) 계산으로 스케일 정규화"
            ]
          }
        ],
        "challenges": [
          {
            "title": "이종 데이터 소스 융합",
            "problem": "기존 Single-stream 방식은 가격/감성 데이터를 단일 입력으로 병합하여 각 모달리티의 고유 특성이 희석되고, cross-modal 상호작용 해석이 제한됨.",
            "solution": "Dual-Stream 아키텍처로 각 스트림이 모달리티 특화 시간적 표현을 학습하도록 분리. 동적 게이팅으로 융합하여 일반화 성능과 해석 가능성 동시 확보."
          },
          {
            "title": "Validation vs Test 성능 괴리",
            "problem": "Dual-Stream 모델의 Validation MAE가 Single-stream 대비 0.47% 높았으나, Test에서는 2.31% 더 낮은 성능을 보임.",
            "solution": "이종 데이터 동적 융합이 과적합을 방지하고 일반화를 강화함을 입증. Single-stream의 mid-sequence 과집중 문제를 해결."
          },
          {
            "title": "시간적 중요도 해석",
            "problem": "Single-stream 모델에서 attention이 분산되어 일관된 시간적 패턴 해석이 어려움.",
            "solution": "Dual-Stream에서 Price stream은 후반 집중, Sentiment stream은 특정 시점 peak로 명확히 분리되어 해석 가능성 향상."
          }
        ],
        "learnings": [
          {
            "title": "모달리티 분리의 중요성",
            "content": "가격 데이터와 감성 데이터는 본질적으로 다른 시간적 패턴을 가집니다. 이를 분리하여 처리하면 각 모달리티의 고유 특성을 보존하면서 더 정교한 융합이 가능합니다."
          },
          {
            "title": "Validation ↗ but Test ↘ 가 의미하는 것",
            "content": "Validation 성능이 약간 떨어져도 Test 성능이 개선되면 일반화 능력이 향상된 것입니다. 과적합 방지와 모델의 견고성이 실전에서 더 중요합니다."
          },
          {
            "title": "Attention 시각화로 해석 가능성 확보",
            "content": "TFT의 attention 가중치를 시각화하면 모델이 언제 어떤 정보에 집중하는지 알 수 있습니다. Price stream의 recent bias와 Sentiment stream의 event-driven peak가 명확히 구분됩니다."
          },
          {
            "title": "향후 연구 방향",
            "content": "동적 융합 메커니즘 고도화, 외생 변수(거시경제 지표 등) 추가 스트림 통합, 다중 모달 예측 프레임워크의 확장성 및 견고성 검증이 가능합니다."
          }
        ],
        "references": [
          {
            "id": 1,
            "title": "Temporal Fusion Transformers for Interpretable Multi-horizon Time Series Forecasting",
            "authors": "B. Lim, S. Ö. Arik, N. Loeff, T. Pfister",
            "year": "2019",
            "source": "arXiv:1912.09363"
          },
          {
            "id": 2,
            "title": "Cryptocurrency Price Prediction using Twitter Sentiment Analysis",
            "authors": "G. B. Haritha and N. B. Sahana",
            "year": "2023",
            "source": "arXiv:2303.09397"
          },
          {
            "id": 3,
            "title": "Price Prediction of Cryptocurrency Using User Sentiments and Quantitative Data",
            "authors": "D. Perera, J. Lim, S. Gunraku, W. H. Lim",
            "year": "2024",
            "source": "Proc. 2024 Int. Conf. Data Sci. Adv. Analytics"
          }
        ],
        "performance": [
          {
            "title": "시나리오별 성능 비교",
            "description": "Validation Set에서는 미세한 차이를 보였으나, Test Set에서는 Scenario 2(Dual-Stream)가 모든 지표에서 우수한 성능을 기록하여 일반화 능력이 입증되었습니다.",
            "headers": [
              "Scenario",
              "Val_MAE",
              "Val_RMSE",
              "Val_Vol",
              "Test_MAE",
              "Test_RMSE",
              "Test_Vol"
            ],
            "rows": [
              [
                "Scenario 1",
                "319.2764",
                "485.3020",
                "483.9223",
                "358.3081",
                "568.6622",
                "562.9303"
              ],
              [
                "Scenario 2",
                "320.7794",
                "484.1341",
                "483.5529",
                "350.0146",
                "555.6910",
                "555.5461"
              ]
            ]
          },
          {
            "title": "제안된 시스템 아키텍처",
            "description": "Price Stream과 Sentiment Stream을 분리하여 처리하고 Gated Fusion을 통해 결합하는 Dual-Stream 구조입니다.",
            "image": "/images/tft/Proposed Model System Architecture.svg"
          },
          {
            "title": "Attention 분포 분석 (Scenario 1 vs 2)",
            "description": "Scenario 1(위)은 Attention이 분산되어 패턴 해석이 어려운 반면, Scenario 2(아래)는 Price Stream이 후반부에 집중하고 Sentiment Stream이 특정 이벤트에 반응하는 명확한 패턴을 보입니다.",
            "image": "/images/tft/Encoder attention distribution in Scenario 2 (a price stream, b sentiment stream).svg"
          },
          {
            "title": "Scenario 1 Attention 분포 (참고)",
            "description": "Single-Stream 모델인 Scenario 1의 Attention 분포입니다. 특정 패턴 없이 분산된 형태를 보여줍니다.",
            "image": "/images/tft/Encoder attention distribution in Scenario 1.png"
          }
        ],
        "pdfLink": "/pdf/Conference_Paper_Dual-Stream-TFT.pdf",
        "image": "/images/tft/Proposed Model System Architecture.svg"
      },
      "color": "#8b5cf6"
    },
    {
      "id": "skill-lstm",
      "type": "skill",
      "label": "LSTM",
      "connections": ["project-paper-lstm"],
      "details": {
        "description": "Long Short-Term Memory 네트워크로, 시계열 데이터의 장기 의존성을 학습할 수 있는 RNN 아키텍처입니다."
      },
      "color": "#ff6b6b"
    },
    {
      "id": "skill-tensorflow",
      "type": "skill",
      "label": "TensorFlow",
      "connections": ["project-paper-lstm"],
      "details": {
        "description": "Google에서 개발한 오픈소스 딥러닝 프레임워크로, 신경망 모델 구축 및 학습에 사용됩니다."
      },
      "color": "#ff6f00"
    },
    {
      "id": "skill-transformer",
      "type": "skill",
      "label": "Transformer",
      "connections": ["project-paper-tft"],
      "details": {
        "description": "Self-Attention 메커니즘을 기반으로 한 딥러닝 아키텍처로, 시계열 예측과 NLP에서 뛰어난 성능을 보입니다."
      },
      "color": "#8b5cf6"
    },
    {
      "id": "skill-pytorch",
      "type": "skill",
      "label": "PyTorch",
      "connections": ["project-paper-tft"],
      "details": {
        "description": "Facebook에서 개발한 오픈소스 딥러닝 프레임워크로, 동적 계산 그래프와 직관적인 API를 제공합니다."
      },
      "color": "#ee4c2c"
    }
  ]
}

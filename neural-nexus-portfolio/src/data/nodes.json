{
  "nodes": [
    {
      "id": "me",
      "type": "main",
      "label": "Min Seok",
      "connections": [
        "project-chatbot",
        "project-portfolio",
        "project-processing",
        "project-cortex",
        "project-cortex-fe",
        "project-paper-lstm",
        "project-paper-tft"
      ],
      "details": {
        "description": "안녕하세요. 견고한 시스템과 구조설계(Backend) 위에 섬세한 마감을 더해, 사용자가 가장 편안함을 느끼는 공간(Frontend)을 구축하는 '디지털 건축가' 최민석입니다.\n\n보이지 않는 뼈대의 안정성부터 사용자의 손끝이 닿는 1픽셀의 디테일까지, 1mm의 오차도 허용하지 않는 정밀한 시공으로 완벽한 서비스 경험을 설계합니다.",
        "personalInfo": [
          { "key": "이름", "value": "최민석" },
          { "key": "생년월일", "value": "2001.10.17" },
          { "key": "전공", "value": "소프트웨어전공" },
          { "key": "연락처", "value": "+82 10 5848 1017" },
          { "key": "이메일", "value": "minseok011017@gmail.com" }
        ],
        "philosophy": {
          "title": "Deep Dive & Wide View",
          "content": "하나의 기술을 깊이 파고드는 'Deep Dive'와 전체 시스템을 조망하는 'Wide View'의 균형을 추구합니다. 단순히 코드를 작성하는 것을 넘어, 비즈니스 목표를 이해하고 최적의 아키텍처를 설계하는 제너럴리스트를 지향합니다."
        },
        "extendedBio": "위대한 건축물이 튼튼한 지반 위에서 비로소 사람을 품을 수 있듯, 소프트웨어 역시 견고한 백엔드 시스템 위에서 사용자를 위한 배려가 시작된다고 믿습니다.\n\n제가 생각하는 프론트엔드는 단순한 겉모습이 아닌, '섬세한 마감(Finishing)'을 통해 사용자가 머무는 공간의 온도를 결정하는 과정입니다. 이는 사용자가 가장 직관적이고 편안하게 목적을 달성할 수 있도록 돕는 '공간 경험(UX) 설계'의 핵심입니다.\n\n단 1mm의 오차가 건물의 안정성을 위협하듯 코드 한 줄의 안일함을 경계하며, 구조적 안정성과 심미적 편안함이 공존하는 디지털 공간을 '시공'합니다. 그리고 이 공간이 단순한 구조물을 넘어, 사용자의 의도를 먼저 읽고 반응하는 살아있는 유기체가 되도록 AI 기술을 더합니다.",
        "profile": {
          "education": [
            {
              "period": "2020.03 – 현재",
              "school": "강남대학교 (Kangnam Univ.)",
              "major": "소프트웨어응용학부",
              "status": "재학 중 (4학년)",
              "gpa": "4.29 / 4.5 (97.6%) - 최근 4학기 학부 수석"
            },
            {
              "period": "2017.03 – 2020.02",
              "school": "효원고등학교",
              "major": "인문계",
              "status": "졸업"
            }
          ],
          "career": [],
          "skills": [
            {
              "category": "Languages",
              "items": [
                "Python",
                "TypeScript",
                "JavaScript",
                "Java",
                "C++",
                "SQL"
              ]
            },
            {
              "category": "Frontend",
              "items": [
                "React",
                "Next.js",
                "Three.js (R3F)",
                "TailwindCSS",
                "Zustand",
                "TanStack Query"
              ]
            },
            {
              "category": "Backend",
              "items": ["FastAPI", "NestJS", "Node.js", "Django", "Spring Boot"]
            },
            {
              "category": "Data & ML",
              "items": [
                "PostgreSQL",
                "TimescaleDB",
                "Redis",
                "TensorFlow",
                "PyTorch",
                "Pandas"
              ]
            },
            {
              "category": "DevOps & Tools",
              "items": [
                "Docker",
                "Git/GitHub",
                "AWS (EC2, S3)",
                "Vercel",
                "Figma"
              ]
            }
          ]
        },
        "keyProjects": [
          {
            "id": "project-cortex",
            "title": "Cortex (Backend)",
            "desc": "AI를 학습시켜 나만의 투자 전략을 만들고 24시간 자동매매를 실행하는 퀀트 플랫폼",
            "tech": ["FastAPI", "TimescaleDB", "Celery", "Redis"]
          },
          {
            "id": "project-cortex-fe",
            "title": "Cortex (Frontend)",
            "desc": "코딩 없이 AI 모델을 설계하고 백테스팅부터 자동매매까지 연결하는 올인원 투자 플랫폼",
            "tech": ["Next.js", "TypeScript", "Zustand", "TanStack Query"]
          },
          {
            "id": "project-chatbot",
            "title": "GangNaengBot (Frontend)",
            "desc": "LLM 응답 지연을 극복한 체감 속도 0ms의 교내 AI 챗봇 서비스",
            "tech": ["React", "TypeScript", "Zustand", "TailwindCSS"]
          },
          {
            "id": "project-portfolio",
            "title": "Neural Portfolio (Frontend)",
            "desc": "뉴런처럼 연결된 프로젝트들을 탐색하는 3D 인터랙티브 포트폴리오",
            "tech": ["R3F", "Three.js", "d3-force", "React"]
          }
        ],
        "researchInterests": [
          {
            "category": "Time Series Forecasting",
            "items": [
              "Transformer 기반 장기 시계열 예측 (TFT, Informer)",
              "금융 데이터의 노이즈 제거 및 특성 추출 방법론"
            ]
          },
          {
            "category": "Human-Computer Interaction",
            "items": [
              "생성형 AI의 의도를 시각화하는 인터페이스 연구",
              "3D 웹 환경에서의 직관적인 사용자 경험(UX) 설계"
            ]
          },
          {
            "category": "System Architecture",
            "items": [
              "MSA(Microservices Architecture) 기반의 확장 가능한 시스템",
              "고성능 데이터 처리를 위한 분산 컴퓨팅 환경 구축"
            ]
          }
        ],
        "awards": [
          {
            "date": "2024.11",
            "title": "ACK 2024 학술대회 최우수 논문상",
            "issuer": "한국정보과학회"
          }
        ]
      },
      "color": "#00ffff"
    },
    {
      "id": "project-chatbot",
      "type": "project",
      "category": "frontend",
      "label": "GangNaengBot-Frontend",
      "connections": [
        "me",
        "skill-react",
        "skill-typescript",
        "skill-vite",
        "skill-tailwind",
        "skill-zustand",
        "skill-axios",
        "skill-i18next"
      ],
      "details": {
        "description": "강남대학교 AI 챗봇 서비스의 프론트엔드 프로젝트로, LLM의 필연적인 응답 지연(1~5초)을 극복하는 **UX 엔지니어링**에 집중했습니다. 낙관적 업데이트(Optimistic UI)와 SWR 패턴을 도입하여, 물리적 네트워크 한계를 넘어 **체감 지연 시간 0ms의 네이티브 앱 수준 반응성**을 달성했습니다.",
        "technologies": [
          "React",
          "TypeScript",
          "Vite",
          "TailwindCSS",
          "Zustand",
          "Axios",
          "i18next"
        ],
        "coreFeatures": [
          "⚡ Optimistic UI Chat: API 응답 전 UI 선반영 + 5회 자동 재시도 + 실패 시 롤백으로 '0ms 대기' 경험 제공",
          "🔄 Hover Prefetching + Request Deduplication: 마우스 진입 시 프리페치 + pendingPrefetches Map으로 중복 요청 차단",
          "💾 Stale-While-Revalidate 캐싱: 캐시 즉시 표시 → 백그라운드 갱신 → 현재 세션이면 UI 업데이트하는 3단계 전략",
          "🌙 FOUC-Free Dark Mode: HTML 파싱 단계에서 테마 클래스 주입하여 흰 화면 깜빡임 원천 차단",
          "🌐 Namespace-Split i18n: common/chat/profile로 번역 파일 분리, 필요한 리소스만 로딩하여 초기 번들 절감"
        ],
        "techStackDocs": [
          {
            "name": "React & TypeScript",
            "description": "Why TypeScript? 복잡한 채팅 데이터 구조(MessageItem, SessionItem)와 사용자 상태를 런타임 에러 없이 관리하기 위함입니다. strict 모드로 null 체크를 강제하여 '채팅방 없음' 상태에서의 버그를 원천 차단했습니다."
          },
          {
            "name": "Vite",
            "description": "Why Vite over CRA? 개발 서버 300ms 구동, HMR 50ms 이내. UI 디테일을 다듬는 반복 작업(Iteration)의 효율을 결정짓는 핵심 요소입니다. Tree Shaking으로 프로덕션 번들도 최적화했습니다."
          },
          {
            "name": "TailwindCSS",
            "description": "Why Utility-First? 컴포넌트 파일과 스타일을 오가는 컨텍스트 스위칭을 제거하고, 디자인 토큰(spacing, colors)을 강제하여 일관된 UI를 빠르게 구축. JIT 컴파일로 사용하는 클래스만 번들에 포함됩니다."
          },
          {
            "name": "Zustand",
            "description": "Why not Redux? 채팅 세션, UI 테마 같은 전역 상태는 복잡한 트랜잭션이 필요 없습니다. 보일러플레이트 없이 훅(Hook) 기반으로 상태를 구독하여 코드량 70% 절감. Map 자료구조로 메시지 캐시도 효율적으로 관리합니다."
          },
          {
            "name": "Axios + Interceptors",
            "description": "Why Interceptors? 모든 API 요청에 토큰을 수동으로 넣는 것은 실수하기 쉽습니다. 요청/응답의 입출구(Gateway)를 단일화하여 인증 로직과 에러 핸들링을 중앙에서 통제했습니다."
          },
          {
            "name": "i18next",
            "description": "Why i18next? 단순 텍스트 치환을 넘어 언어별 복수형 처리, 네임스페이스 분리, 브라우저 언어 감지 → 로컬 스토리지 → 기본값(한국어)의 우아한 폴백 로직을 지원하는 가장 성숙한 솔루션입니다."
          }
        ],
        "link": "https://github.com/sleepyMS/GangNaengBot-FE",
        "deployLink": "https://gang-naeng-bot-fe.vercel.app/",
        "blogLink": "https://me-in-journey.tistory.com/entry/React-AI-%EC%B1%97%EB%B4%87%EC%9D%98-%EC%B2%B4%EA%B0%90-%EC%86%8D%EB%8F%84%EB%A5%BC-%EB%86%92%EC%9D%B8-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%B5%9C%EC%A0%81%ED%99%94-%EC%97%AC%EC%A0%95",
        "features": [
          {
            "title": "Optimistic UI & Error Recovery (Zero-Latency)",
            "items": [
              "Instant Feedback: `useChatStore.ts`의 `sendMessage` 함수에서 API 호출 전 `set`으로 로컬 메시지 상태를 선행 업데이트. 사용자는 '전송됨'을 즉시 인지합니다.",
              "Smart Rollback: 네트워크 실패 시 `messages.slice(0, -1)`로 낙관적 메시지를 롤백, 새 세션이면 빈 배열로 초기화하여 일관성 유지.",
              "Auto-Retry (Transparent Resilience): 빈 AI 응답에 대해 5회 × 500ms 간격 자동 재시도. 일시적 네트워크 오류나 AI 서버 지연을 사용자가 전혀 인지하지 못하게 복구합니다."
            ]
          },
          {
            "title": "Intelligent Session Prefetching (SWR Pattern)",
            "items": [
              "Hover Prefetch: `prefetchSession()` 함수로 마우스 진입 시 메시지 목록을 백그라운드 로드. 클릭 시점에는 0ms로 캐시된 데이터 즉시 표시.",
              "Request Deduplication: `pendingPrefetches` Map으로 동일 세션 중복 요청 차단. 이미 진행 중이면 기존 Promise 재사용.",
              "Stale-While-Revalidate: 캐시 있으면 즉시 표시 후 백그라운드에서 최신 데이터 갱신. 현재 세션이면 UI도 조용히(Seamless) 업데이트."
            ]
          },
          {
            "title": "Secure Token Rotation (Lock & Queue Patterns)",
            "items": [
              "Centralized Handling: Axios Interceptor에서 401 Unauthorized 응답 감지 시 자동 로그아웃 + 리다이렉트",
              "Guest Mode: 로그인 없이도 임시 user_id로 채팅 가능. 세션 생성 시 user_id를 Zustand에 저장하여 후속 요청에 활용."
            ]
          },
          {
            "title": "Seamless Theme Integration (FOUC Prevention)",
            "items": [
              "System Sync: `window.matchMedia` API로 OS 다크모드 변경 이벤트를 구독하여 앱 테마 즉시 동기화",
              "FOUC 원천 차단: HTML 파싱 시점에 로컬 스토리지 설정을 읽어 <html>에 클래스 주입. JS 실행 전 테마 적용 완료."
            ]
          }
        ],
        "optimizations": [
          {
            "title": "Hover Prefetching으로 체감 로딩 '0ms' 달성",
            "items": [
              "Why: 채팅방 클릭 후 데이터 로드까지의 스피너도 대화 흐름을 끊습니다.",
              "How: `mouseEnter` 이벤트에 `prefetchSession()` 연결. Map 기반 캐시로 중복 요청 방지하고 세션별 메시지 저장.",
              "Impact: 사용자가 클릭하는 순간 이미 데이터 준비 완료. 물리적 로딩 시간과 무관하게 '즉시' 전환되는 체감 성능 제공."
            ]
          },
          {
            "title": "Request Deduplication으로 서버 부하 절감",
            "items": [
              "Why: 빠른 연속 클릭으로 동일 API 5회 호출 → 불필요한 네트워크 트래픽 + 서버 부하.",
              "How: `pendingPrefetches.get(sessionId)`로 진행 중인 요청 확인. 있으면 새 요청 대신 기존 Promise await.",
              "Impact: 동일 세션 다중 클릭 시에도 API 호출 단 1회로 제한."
            ]
          },
          {
            "title": "Optimistic UI로 응답 속도 대폭 개선",
            "items": [
              "Why: LLM 특성상 1-5초의 응답 지연이 필연적이며, 이는 사용자 이탈의 주원인입니다.",
              "How: API 응답을 기다리지 않고 UI를 먼저 업데이트하는 낙관적 패턴 적용.",
              "Impact: 메시지 전송 체감 시간 1-2초 → 0ms로 단축."
            ]
          },
          {
            "title": "Vite + Tailwind JIT로 번들 최적화",
            "items": [
              "Why: 모바일 3G 환경에서 초기 로딩 속도는 이탈률과 직결됩니다.",
              "How: Vite Tree Shaking + Tailwind JIT 컴파일러로 사용되지 않는 코드/스타일 배제.",
              "Impact: 프로덕션 번들 크기 최소화, FCP(First Contentful Paint) 1.5초 이내 달성."
            ]
          }
        ],
        "performance": [
          {
            "title": "사용자 경험(UX) 정량적 개선 지표",
            "description": "서버 응답 속도를 물리적으로 줄이는 데 한계가 뚜렷한 LLM 서비스에서, 프론트엔드 기술만으로 체감 성능을 극대화했습니다.",
            "headers": [
              "전략 (Pattern)",
              "개선 항목 (Metric)",
              "Before",
              "After"
            ],
            "rows": [
              ["Optimistic UI", "메시지 전송 체감 시간", "1~2초", "0ms ⚡"],
              [
                "SWR + Prefetching",
                "세션(채팅방) 전환 로딩",
                "500ms~1s",
                "즉시 (0ms) ⚡"
              ],
              [
                "Auto-Retry Logic",
                "일시적 네트워크 에러 노출",
                "빈번함",
                "0회 (사용자 인지 불가)"
              ],
              [
                "Lock & Queue",
                "토큰 갱신 시 중복 요청",
                "N회 발생",
                "1회로 제한"
              ]
            ]
          }
        ],
        "challenges": [
          {
            "title": "비동기 데이터와 UI 상태의 괴리 (Async State Sync)",
            "problem": "서버 응답 지연 시 사용자가 '멈춤'으로 인지하거나 중복 전송을 시도하여 데이터 일관성이 깨지는 문제가 있었습니다.",
            "solution": "낙관적 UI(Optimistic UI) 패턴을 도입하여 API 응답 대기 없이 로컬 상태를 선행 업데이트(Pre-commit)하고, 실패 시에만 롤백하는 트랜잭션 방식으로 UX 반응성과 데이터 무결성을 동시에 확보했습니다."
          },
          {
            "title": "데이터 최신성 동기화와 로딩 지연 (SWR Pattern)",
            "problem": "세션 전환 시마다 로딩이 발생하여 UX가 끊기거나, 단순 캐싱 사용 시 데이터가 낡은(Stale) 상태로 남는 동기화 딜레마가 있었습니다.",
            "solution": "SWR(Stale-While-Revalidate) 전략을 직접 구현했습니다. 캐시된 데이터를 즉시(0ms) 렌더링하고, 백그라운드에서 조용히 최신 데이터를 갱신(Revalidate)합니다. 또한 `Map`을 활용한 요청 중복 제거(Deduplication)로 불필요한 네트워크 부하를 차단했습니다."
          },
          {
            "title": "일시적 장애와 복원력(Transparent Resilience) 확보",
            "problem": "LLM 응답이 비어있거나 타임아웃이 발생할 때, 단순 에러 메시지(500)를 노출하면 사용자 경험이 크게 저하되었습니다.",
            "solution": "백그라운드 자동 재시도(Silent Retry) 로직을 구현했습니다. 500ms 간격으로 최대 5회 재시도하며, 사용자는 재시도 과정을 인지하지 못하고('AI 생각 중') 성공된 결과만 볼 수 있게 하여 서비스 신뢰도를 높였습니다."
          },
          {
            "title": "인증 상태 관리의 파편화와 유지보수성",
            "problem": "각 컴포넌트에서 401 Unauthorized 에러와 토큰 만료를 개별적으로 처리하다 보니 코드가 중복되고, 예외 케이스 누락으로 보안 구멍이 발생했습니다.",
            "solution": "Axios Interceptor를 도입하여 인증 에러 핸들링을 중앙화(Centralization)했습니다. 입출구 단계에서 토큰 만료를 일괄 감지하고 자동 로그아웃/리다이렉트를 처리하여 비즈니스 로직과 시스템 관심사를 완벽히 분리했습니다."
          }
        ],
        "learnings": [
          {
            "title": "UX가 곧 성능이다 (Perceived Performance)",
            "content": "물리적 로딩 시간을 0으로 만들 수는 없지만, 낙관적 UI와 프리페칭으로 사용자가 '느끼는' 대기 시간을 0으로 만들 수 있습니다. 실제 성능 개선보다 체감 성능 개선이 사용자 만족도에 더 큰 영향을 미친다는 것을 배웠습니다."
          },
          {
            "title": "Map 자료구조의 활용",
            "content": "`messageCache: Map<string, MessageItem[]>`과 `pendingPrefetches: Map<string, Promise>`처럼 Map을 활용하면 O(1) 조회로 캐싱과 중복 방지를 간결하게 구현할 수 있습니다. 객체 대신 Map을 쓰면 삽입/삭제 시 참조 안정성도 확보됩니다."
          },
          {
            "title": "선언적 추상화의 힘",
            "content": "API 호출, 에러 처리, 테마 동기화 같은 반복 로직을 Custom Hook과 Interceptor로 추상화하니, UI 컴포넌트는 오직 '표현'에만 집중할 수 있었습니다. 비즈니스 로직 변경 시에도 한 곳만 수정하면 되는 유연함을 얻었습니다."
          },
          {
            "title": "글로벌 서비스에 대한 마인드셋",
            "content": "i18n을 단순 번역으로 접근했다가 유지보수 지옥을 맛보았습니다. 초기 설계 단계부터 네임스페이스 분리와 확장성을 고려해야 하며, 언어는 단순한 텍스트가 아니라 문화적 맥락(날짜 포맷, 어순 등)을 포함한다는 것을 깊이 이해하게 되었습니다."
          },
          {
            "title": "상태 관리는 '어디에' 두느냐가 핵심",
            "content": "`pendingPrefetches`는 컴포넌트 외부(모듈 스코프)에, `messageCache`는 Zustand 내부에 저장했습니다. 리렌더링 트리거 여부에 따라 상태의 위치를 결정하는 것이 성능과 복잡도를 모두 관리하는 핵심임을 배웠습니다."
          }
        ],
        "codeExamples": [
          {
            "title": "Optimistic UI + 자동 재시도 + 롤백",
            "category": "performance",
            "description": "Why Optimistic? API 응답을 기다리는 0.5초도 대화 흐름을 끊습니다. 메시지를 먼저 표시하고, 빈 응답은 5회 재시도, 실패 시에만 롤백하여 '즉각 반응' 경험을 제공합니다.",
            "filePath": "src/store/useChatStore.ts",
            "githubLink": "https://github.com/sleepyMS/GangNaengBot-FE/blob/main/src/store/useChatStore.ts",
            "snippet": "// 1. 낙관적 UI: 서버 응답 전 메시지 표시\nset(state => ({ messages: [...state.messages, userMessage], isSending: true }));\n\ntry {\n  const response = await chatService.sendMessage({ session_id, message });\n  \n  // 2. 빈 응답 자동 재시도 (최대 5회)\n  for (let i = 0; i < 5 && !response.text?.trim(); i++) {\n    await new Promise(r => setTimeout(r, 500));\n    response = await chatService.sendMessage({ session_id, message });\n  }\n  \n  set(state => ({ messages: [...state.messages, assistantMessage] }));\n} catch {\n  // 3. 실패 시 롤백\n  set(state => ({ messages: state.messages.slice(0, -1) }));\n}"
          },
          {
            "title": "Hover Prefetching + Request Deduplication",
            "category": "performance",
            "description": "Why Prefetch? 클릭 후 로딩 스피너도 UX를 해칩니다. 마우스 진입 시 데이터를 미리 로드하고, Map으로 중복 요청을 차단하여 서버 부하를 절감합니다.",
            "filePath": "src/store/useChatStore.ts",
            "githubLink": "https://github.com/sleepyMS/GangNaengBot-FE/blob/main/src/store/useChatStore.ts",
            "snippet": "const pendingPrefetches = new Map<string, Promise<MessageItem[]>>();\n\nprefetchSession: (sessionId: string) => {\n  // 캐시 있으면 스킵\n  if (messageCache.has(sessionId)) return;\n  // 이미 진행 중이면 중복 요청 방지\n  if (pendingPrefetches.has(sessionId)) return;\n  \n  const promise = sessionsService.getSessionMessages(sessionId)\n    .then(res => {\n      messageCache.set(sessionId, res.messages);\n      return res.messages;\n    })\n    .finally(() => pendingPrefetches.delete(sessionId));\n  \n  pendingPrefetches.set(sessionId, promise);\n}"
          },
          {
            "title": "Stale-While-Revalidate 캐싱",
            "category": "performance",
            "description": "Why SWR? 항상 최신 데이터를 가져오면 매번 로딩. 캐시만 쓰면 오래된 데이터. 둘의 장점을 결합하여 빠른 응답성과 최신성을 동시에 확보합니다.",
            "filePath": "src/store/useChatStore.ts",
            "githubLink": "https://github.com/sleepyMS/GangNaengBot-FE/blob/main/src/store/useChatStore.ts",
            "snippet": "selectSession: async (sessionId, forceRefresh = false) => {\n  const cached = messageCache.get(sessionId);\n  \n  if (cached && !forceRefresh) {\n    // 1. 캐시 즉시 표시\n    set({ messages: cached, isLoading: false });\n    \n    // 2. 백그라운드에서 최신 데이터 가져오기\n    sessionsService.getSessionMessages(sessionId)\n      .then(res => {\n        messageCache.set(sessionId, res.messages);\n        // 3. 현재 세션이면 UI도 조용히 업데이트\n        if (get().currentSessionId === sessionId) {\n          set({ messages: res.messages });\n        }\n      });\n    return;\n  }\n  // 캐시 없으면 일반 로딩...\n}"
          },
          {
            "title": "게스트 모드 세션 자동 생성",
            "category": "business",
            "description": "Why Auto-Create? 로그인 없이도 챗봇을 즉시 사용하게 하고 싶었습니다. 첫 메시지 전송 시점에 세션을 자동 생성하고, 메시지 내용으로 제목을 자동 설정합니다.",
            "filePath": "src/store/useChatStore.ts",
            "githubLink": "https://github.com/sleepyMS/GangNaengBot-FE/blob/main/src/store/useChatStore.ts",
            "snippet": "sendMessage: async (message, createSessionIfNeeded = false) => {\n  let { currentSessionId } = get();\n  \n  // 세션이 없고 자동 생성 플래그가 true면\n  if (!currentSessionId && createSessionIfNeeded) {\n    const res = await sessionsService.createSession();\n    currentSessionId = res.session_id;\n    \n    const newSession = {\n      sid: res.session_id,\n      title: message.slice(0, 50) + (message.length > 50 ? '...' : ''),\n      is_active: true,\n    };\n    set({ sessions: [newSession, ...sessions], currentSessionId });\n  }\n  // 이후 메시지 전송...\n}"
          },
          {
            "title": "낙관적 삭제 + 실패 시 롤백",
            "category": "performance",
            "description": "Why Optimistic Delete? 삭제 확인을 기다리는 동안 UI가 멈추면 '느리다'고 느낍니다. 즉시 UI에서 제거하고, 실패 시에만 복원하여 반응성을 극대화합니다.",
            "filePath": "src/store/useChatStore.ts",
            "githubLink": "https://github.com/sleepyMS/GangNaengBot-FE/blob/main/src/store/useChatStore.ts",
            "snippet": "deleteSession: async (sessionId) => {\n  const { sessions, currentSessionId } = get();\n  const deleted = sessions.find(s => s.sid === sessionId);\n  \n  // 1. 낙관적 UI: 즉시 삭제\n  set({ sessions: sessions.filter(s => s.sid !== sessionId) });\n  \n  try {\n    await sessionsService.deleteSession(sessionId);\n  } catch {\n    // 2. 실패 시 롤백: 삭제 취소\n    if (deleted) {\n      set(state => ({\n        sessions: [deleted, ...state.sessions],\n        error: '삭제에 실패했습니다.'\n      }));\n    }\n  }\n}"
          },
          {
            "title": "i18n 네임스페이스 분리 구조",
            "category": "architecture",
            "description": "Why Namespace? 모든 번역을 한 파일에 넣으면 초기 로딩이 느려지고 키 충돌 위험도 있습니다. common/chat/profile로 분리하여 필요한 리소스만 로딩하고 관리 용이성을 확보했습니다.",
            "filePath": "src/i18n/index.ts",
            "githubLink": "https://github.com/sleepyMS/GangNaengBot-FE/blob/main/src/i18n/index.ts",
            "snippet": "import i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\n\ni18n.use(LanguageDetector).use(initReactI18next).init({\n  fallbackLng: 'ko',\n  ns: ['common', 'chat', 'profile'],  // 네임스페이스 분리\n  defaultNS: 'common',\n  interpolation: { escapeValue: false },\n});"
          }
        ]
      },
      "color": "#c026d3"
    },
    {
      "id": "project-portfolio",
      "type": "project",
      "category": "frontend",
      "label": "Neural Portfolio",
      "connections": ["me", "skill-threejs", "skill-react", "skill-gsap"],
      "details": {
        "description": "지금 보고 계신 포트폴리오입니다! 정적인 사이트맵 대신 프로젝트들을 상호 연결된 뉴런으로 시각화한 3D 신경망 기반 포트폴리오입니다. 단순히 '예쁜 3D'가 아닌, '끊김 없는 60fps 경험'과 '직관적인 탐색 UX'를 핵심 과제로 두고, d3-force 물리 엔진, Custom Easing 애니메이션, Dual Ref 이벤트 처리 등 엔지니어링 깊이를 더했습니다.",
        "link": "https://github.com/sleepyMS/MS-Mind",
        "coreFeatures": [
          "⚡ 300-tick Warm-up: 물리 엔진 초기화 시 발산(Explosion) 현상 방지. 렌더링 전 동기 실행으로 '균형 잡힌 신경망' 즉시 표시",
          "🎥 Custom Cubic Easing Camera: 라이브러리 없이 easeInOutCubic 수학 공식 직접 구현. sceneRotation 역연산으로 항상 노드 정면 응시",
          "🔄 180° Theme Rotation: 테마 전환 시 전체 씬 180° 회전 애니메이션 + Bloom/Vignette 동적 보간으로 '우주→하늘' 서사 표현",
          "🖱️ Dual Ref Hover Handling: WebGL Mesh와 DOM Label 이벤트 시차 극복. 10ms 디바운스로 포커스 유실 방지",
          "📊 Zustand Transient Update: 60fps 루프에서 React 리렌더링 최소화. useRef로 애니메이션 변수 직접 변이하여 프레임 드랍 방지",
          "🔗 BFS 간접 연결 경로 탐색: 필터링된 노드 사이의 숨겨진 연결을 BFS로 탐색하여 점선으로 시각화. 관계 맥락 유지",
          "📱 스와이프 각도 감지: 수직/수평 이동량 비교로 세로 스크롤과 노드 순회 스와이프를 정확히 구분. 모바일 UX 개선"
        ],
        "techStackDocs": [
          {
            "name": "React Three Fiber (R3F)",
            "description": "Why R3F over Vanilla Three.js? React 상태와 3D 씬 동기화의 복잡성을 해결하기 위함입니다. JSX로 씬 그래프를 선언적으로 관리하고, useFrame 훅으로 애니메이션 루프에 쉽게 접근하여 유지보수성을 극대화했습니다."
          },
          {
            "name": "Zustand + Transient Updates",
            "description": "Why Transient? 60fps 렌더링에서 매 프레임 setState를 호출하면 React Reconciler 오버헤드로 프레임 드랍이 발생합니다. 애니메이션 변수(progress, position)는 useRef로 관리하고, UI에 반영할 최종 상태만 set()으로 업데이트하여 성능 병목을 원천 차단했습니다."
          },
          {
            "name": "d3-force-3d",
            "description": "Why Physics Engine? 수동 배치는 쉽지만 데이터 추가 시 재배치가 필요합니다. 노드 간 인력/척력을 시뮬레이션하여 데이터가 스스로 균형 잡힌 구조를 찾아가는 '살아있는' 레이아웃을 구현했습니다. forceCollide()로 노드 충돌도 방지합니다."
          },
          {
            "name": "Post-processing (Bloom & Vignette)",
            "description": "Why Effects? 단순히 예뻐 보이기 위함이 아닙니다. Bloom은 핵심 노드에 시선을 집중시키고, Vignette는 주변부를 어둡게 하여 화면 중앙 몰입도를 높입니다. 테마별로 Intensity를 동적 조절하여 라이트 모드 Whiteout을 방지했습니다."
          },
          {
            "name": "GSAP-free Animation",
            "description": "Why No GSAP? 번들 크기 절감과 학습 목적입니다. easeInOutCubic 공식(`t < 0.5 ? 4*t³ : 1-((-2t+2)³)/2`)을 직접 구현하고, THREE.Vector3.lerpVectors()로 보간하여 라이브러리 없이도 부드러운 애니메이션을 달성했습니다."
          }
        ],
        "optimizations": [
          {
            "title": "BFS 기반 간접 연결 경로 탐색",
            "items": [
              "Why: 카테고리 필터로 중간 노드가 숨겨지면 관련 노드들의 연결 관계가 끊어져 보이는 UX 문제 발생.",
              "How: `findConnectedVisibleNodes()` 함수에서 BFS 알고리즘으로 숨겨진 노드를 통해 연결된 visible 노드 쌍 탐색. Queue 기반 레벨 순회로 최단 경로 보장.",
              "Impact: 필터 적용 시에도 노드 간 관계가 점선으로 유지되어 정보 손실 없이 맥락 파악 가능."
            ]
          },
          {
            "title": "Ref 기반 60fps 애니메이션 루프",
            "items": [
              "Why: useFrame 내에서 setState를 호출하면 60fps × React Reconciler = 프레임 드랍.",
              "How: `animationRef.current.progress += delta`로 ref를 직접 변이. camera.position도 lerpVectors()로 직접 조작. 완료 시에만 setIsAnimating(false) 호출.",
              "Impact: React 개입 없이 끊김 없는 60fps 애니메이션 보장."
            ]
          },
          {
            "title": "물리 엔진 300회 사전 연산",
            "items": [
              "Why: 물리 엔진이 안정화될 때까지 노드들이 요동치는(Jittering) 시각적 노이즈는 사용자 첫인상을 망칩니다.",
              "How: `for (let i = 0; i < 300; i++) simulation.tick()` 동기 루프로 렌더링 전 300회 선행 연산. useMemo로 메모이제이션하여 재계산 방지.",
              "Impact: 사용자는 즉시 '안정된 신경망'을 마주하여 첫인상 완성도를 높였습니다."
            ]
          },
          {
            "title": "씬 회전 오프셋 역연산",
            "items": [
              "Why: 씬이 회전한 상태에서 단순 좌표 이동은 카메라가 노드의 측면/후면을 비춥니다.",
              "How: `baseOffset.applyAxisAngle(new THREE.Vector3(0,1,0), sceneRotation)`으로 카메라 오프셋을 씬 회전에 맞춰 역회전.",
              "Impact: 씬이 어떻게 회전해 있든 카메라는 항상 노드의 '정면'을 응시합니다."
            ]
          },
          {
            "title": "WebGL-DOM 이중 Ref 이벤트 처리",
            "items": [
              "Why: WebGL Mesh와 DOM Label은 서로 다른 이벤트 루프를 타서 빠른 마우스 이동 시 hover 상태가 유실됩니다.",
              "How: meshHoverRef, labelHoverRef를 별도 관리하고, mouseLeave 시 10ms setTimeout 후 둘 다 false면 hover 해제.",
              "Impact: 기술적 한계로 인한 UI 깜빡임을 극복하고 매끄러운 포커싱 경험 제공."
            ]
          },
          {
            "title": "모바일 스와이프 각도 감지",
            "items": [
              "Why: 세로 스크롤 시도 시 수평 스와이프가 민감하게 발동되어 의도치 않은 노드 전환 발생.",
              "How: touchStartY, touchEndY 상태 추가. `deltaY > deltaX`면 스크롤로 판단하여 노드 순회 무시. 터치 종료 시에도 최종 방향 재확인.",
              "Impact: 세로 스크롤과 수평 스와이프가 명확히 구분되어 모바일 터치 UX 대폭 개선."
            ]
          },
          {
            "title": "거리 기반 적응형 모달 딜레이",
            "items": [
              "Why: 1초 고정 딜레이는 가까운 노드에서는 느리고, 먼 노드에서는 즉시 열려 몰입감을 해칩니다.",
              "How: `delay = Math.min(distance * 15, 800)` 공식으로 거리에 비례한 지연 시간 적용. 아주 가까우면 75ms 만에 즉시 반응.",
              "Impact: 근거리 탐색 시 앱이 훨씬 '빠릿하다'고 느끼게 만들었습니다."
            ]
          },
          {
            "title": "연결 노드 라벨 하이라이팅",
            "items": [
              "Why: 복잡한 신경망에서 내가 선택한 노드가 어떤 스킬과 연결되었는지 파악하기 어렵습니다.",
              "How: `isHighlighted` 상태를 전파하여, 프로젝트 노드 호버 시 연결된 모든 스킬 노드의 라벨을 재귀적으로 노출.",
              "Impact: 사용자가 노드 간의 관계를 직관적으로 파악할 수 있게 되었습니다."
            ]
          }
        ],
        "challenges": [
          {
            "title": "3D 좌표계와 카메라 오리엔테이션 동기화",
            "problem": "테마 전환 시 씬이 180° 회전한 상태에서, 노드 클릭 시 카메라가 노드의 뒤통수를 비추는 치명적 UX 결함이 발생했습니다.",
            "solution": "단순 이동 대신 '시선(LookAt)'을 제어했습니다. 현재 sceneRotation을 읽어 카메라 오프셋 벡터를 같은 각도로 회전시켜, 씬의 회전 상태와 무관하게 항상 노드 정면을 바라보도록 수학적으로 보정했습니다."
          },
          {
            "title": "WebGL + DOM 하이브리드 렌더링의 이벤트 소실",
            "problem": "HTML 라벨은 DOM 요소이므로 WebGL mouseleave 이벤트와 미세한 시차가 존재합니다. Mesh에서 Label로 마우스 이동 시 0.01초 동안 'hover 없음' 상태가 되어 깜빡이는 UX 결함이 발생했습니다.",
            "solution": "React 비동기 업데이트를 신뢰하는 대신, useRef로 Mesh/Label hover 상태를 즉시(Synchronous) 캡처하고, 10ms setTimeout 후 '둘 다 false면 hover 해제'하는 Dual Ref 패턴을 고안했습니다."
          },
          {
            "title": "테마별 Post-processing 밸런싱",
            "problem": "다크 모드에서 아름다운 Bloom 효과가 라이트 모드에서는 화면 전체를 하얗게 날려버리는(Whiteout) 시각적 문제를 일으켰습니다.",
            "solution": "테마 전환은 단순 색상 변경이 아니라 '빛의 물리적 특성'이 바뀌는 것입니다. theme 상태에 따라 Bloom의 threshold, intensity를 동적으로 조절하고, THREE.MathUtils.lerp()로 부드럽게 보간하여 어떤 조명 환경에서도 가독성과 심미성을 유지했습니다."
          },
          {
            "title": "물리 엔진 초기 발산(Explosion) 현상",
            "problem": "d3-force 시뮬레이션 시작 시 노드들이 랜덤 위치에서 폭발적으로 흩어졌다가 서서히 안정화되는데, 이 과정이 사용자에게 노출되면 '불안정한 앱'으로 인식됩니다.",
            "solution": "렌더링 전에 동기적으로 300회 tick()을 실행하여 시뮬레이션을 '사전에 완료'시킵니다. 사용자는 이미 안정화된 레이아웃만 보게 되어 첫인상의 완성도를 높였습니다."
          },
          {
            "title": "노드 상세보기 vs 전체 맥락 유지",
            "problem": "초기에는 선택한 노드를 자세히 보여주기 위해 카메라를 아주 가까이(`z=8`) 이동시켰으나, 3D Mesh가 2D Modal 오버레이와 겹쳐 가독성을 해치고 전체 맥락을 잃어버리는 문제가 있었습니다.",
            "solution": "'Zoom In' 대신 'Scale Up' 전략을 채택했습니다. 카메라는 편안한 거리(`z=25`)를 유지하되, 선택된 노드의 크기만 `2.0배`로 키워 시각적 강조와 맥락 유지를 동시에 달성했습니다."
          },
          {
            "title": "모바일 탭 스와이프와 노드 순회 스와이프 충돌",
            "problem": "모달 내 탭이 많으면 탭 영역을 수평 스크롤해야 하는데, 이때 노드 순회용 스와이프와 동시에 발동되어 두 기능이 충돌했습니다.",
            "solution": "`tabsRef`로 탭 영역을 참조하고, `onTouchStart`에서 터치 시작 위치가 탭 영역 내인지 판별. 탭 영역 터치 시 즉시 return하여 노드 순회 로직 비활성화. 터치 컨텍스트에 따른 제스처 분리로 UX 충돌 해결."
          }
        ],
        "codeExamples": [
          {
            "title": "BFS 간접 연결 경로 탐색 알고리즘",
            "category": "algorithm",
            "description": "Why BFS? 필터로 숨겨진 노드 사이의 관계를 유지해야 합니다. DFS는 경로를 찾지만 '최단'을 보장하지 않고, BFS는 레벨 순회로 가장 가까운 visible 노드만 연결합니다.",
            "filePath": "src/components/canvas/Scene.tsx",
            "githubLink": "https://github.com/sleepyMS/MS-Mind/blob/main/neural-nexus-portfolio/src/components/canvas/Scene.tsx",
            "snippet": "const findConnectedVisibleNodes = (startId: string, visited: Set<string>): string[] => {\n  const result: string[] = [];\n  const queue = [startId];  // BFS 큐\n  visited.add(startId);\n\n  while (queue.length > 0) {\n    const currentId = queue.shift()!;\n    const currentNode = nodes.find(n => n.id === currentId);\n    \n    for (const neighborId of currentNode.connections) {\n      if (visited.has(neighborId)) continue;\n      visited.add(neighborId);\n      \n      if (visibleNodeIds.has(neighborId)) {\n        result.push(neighborId);  // visible 노드 발견\n      } else {\n        queue.push(neighborId);   // 숨겨진 노드 통해 계속 탐색\n      }\n    }\n  }\n  return result;\n};"
          },
          {
            "title": "Ref 기반 60fps 애니메이션 최적화",
            "category": "performance",
            "description": "Why Ref? useFrame 내에서 setState를 호출하면 60fps × Reconciler = 프레임 드랍. animationRef.current를 직접 변이하고, 완료 시에만 setIsAnimating(false)를 호출합니다.",
            "filePath": "src/components/canvas/CameraManager.tsx",
            "githubLink": "https://github.com/sleepyMS/MS-Mind/blob/main/neural-nexus-portfolio/src/components/canvas/CameraManager.tsx",
            "snippet": "// 애니메이션 상태를 ref로 관리 (렌더링 최적화)\nconst animationRef = useRef({\n  isActive: false,\n  progress: 0,\n  startPosition: new THREE.Vector3(),\n  targetPosition: new THREE.Vector3(),\n  duration: 1.5,\n});\n\nuseFrame((_, delta) => {\n  if (!animationRef.current.isActive) return;\n  animationRef.current.progress += delta / anim.duration; // ref 직접 변이\n  // ... camera.position 조작 ...\n});"
          },
          {
            "title": "easeInOutCubic 수학 공식 직접 구현",
            "category": "animation",
            "description": "Why No GSAP? 번들 크기 절감 + 수학 공식 이해. t < 0.5 구간에서 4t³으로 가속, 이후 1-((-2t+2)³)/2로 감속하는 S-커브를 직접 구현했습니다.",
            "filePath": "src/components/canvas/CameraManager.tsx",
            "githubLink": "https://github.com/sleepyMS/MS-Mind/blob/main/neural-nexus-portfolio/src/components/canvas/CameraManager.tsx",
            "snippet": "useFrame((_, delta) => {\n  anim.progress += delta / anim.duration;\n  \n  // easeInOutCubic 공식 직접 구현\n  const t = anim.progress;\n  const ease = t < 0.5 \n    ? 4 * t * t * t \n    : 1 - Math.pow(-2 * t + 2, 3) / 2;\n\n  // Lerp에 Easing 적용\n  camera.position.lerpVectors(startPos, targetPos, ease);\n  controls.target.lerpVectors(startLookAt, targetLookAt, ease);\n});"
          },
          {
            "title": "씬 회전 역연산으로 카메라 정면 응시",
            "category": "3d-math",
            "description": "Why Offset Rotation? 씬이 회전한 상태에서 고정 오프셋을 더하면 카메라가 노드 측면을 비춥니다. 오프셋 벡터를 씬 회전과 같은 각도로 회전시켜 항상 정면을 바라봅니다.",
            "filePath": "src/components/canvas/CameraManager.tsx",
            "githubLink": "https://github.com/sleepyMS/MS-Mind/blob/main/neural-nexus-portfolio/src/components/canvas/CameraManager.tsx",
            "snippet": "// 타겟 좌표에 씬 회전 적용\nconst targetLookAt = new THREE.Vector3(...cameraTarget)\n  .applyAxisAngle(new THREE.Vector3(0, 1, 0), sceneRotation);\n\n// 오프셋도 같은 각도로 회전\nconst baseOffset = new THREE.Vector3(0, 2, 8);\nconst rotatedOffset = baseOffset.clone()\n  .applyAxisAngle(new THREE.Vector3(0, 1, 0), sceneRotation);\n\nconst targetCameraPosition = targetLookAt.clone().add(rotatedOffset);"
          },
          {
            "title": "물리 엔진 300회 사전 연산",
            "category": "performance",
            "description": "Why Warm-up? 물리 엔진이 안정화될 때까지 기다리면 노드들이 요동치는 모습이 노출됩니다. 렌더링 전에 300회 tick()을 동기 실행하여 '이미 완성된 형태'로 시작합니다.",
            "filePath": "src/hooks/useForceGraph.ts",
            "githubLink": "https://github.com/sleepyMS/MS-Mind/blob/main/neural-nexus-portfolio/src/hooks/useForceGraph.ts",
            "snippet": "const simulation = forceSimulation(simNodes, 3)\n  .force('link', forceLink(links).strength(0.5))\n  .force('charge', forceManyBody().strength(-80))\n  .force('center', forceCenter(0, 0, 0))\n  .force('collide', forceCollide().radius(2).strength(0.7));\n\n// 렌더링 전 300회 동기 실행 (Stable Initialization)\nfor (let i = 0; i < 300; i++) {\n  simulation.tick();\n}\nsimulation.stop(); // 연산 종료 후 위치 고정"
          },
          {
            "title": "거리 기반 이벤트 동기화",
            "category": "ux-engineering",
            "description": "Why Static Timeout Fails? 고정된 지연 시간은 가까운 노드에서는 답답하고, 먼 노드에서는 너무 빠릅니다. 이동 거리를 실시간으로 계산하여 카메라 애니메이션 시간과 모달 오픈 타이밍을 동기화했습니다.",
            "filePath": "src/components/canvas/Node.tsx",
            "githubLink": "https://github.com/sleepyMS/MS-Mind/blob/main/neural-nexus-portfolio/src/components/canvas/Node.tsx",
            "snippet": "// Node.tsx: Distance-based Delay\nconst distance = camera.position.distanceTo(targetCameraPos);\n// Close: ~75ms (Instant), Far: 800ms (Capped)\nconst delay = Math.min(distance * 15, 800);\n\nsetTimeout(() => setModalOpen(true), delay);\n\n// CameraManager.tsx: Matching Duration\nanimationRef.current.duration = Math.min(\n  Math.max(distance * 0.06, 0.6), // Min 0.6s\n  2.0 // Max 2.0s\n);"
          },
          {
            "title": "테마 토글 시 180° 씬 회전 애니메이션",
            "category": "ux",
            "description": "Why 180° Rotation? 단순 색상 전환은 밋밋합니다. 다크(우주/달) → 라이트(하늘/태양) 테마 서사에 맞춰 전체 씬이 반대편을 향하도록 180° 회전시켜 '세계가 바뀌는' 몰입감을 줍니다.",
            "filePath": "src/stores/useAppStore.ts",
            "githubLink": "https://github.com/sleepyMS/MS-Mind/blob/main/neural-nexus-portfolio/src/stores/useAppStore.ts",
            "snippet": "toggleTheme: () => {\n  set((state) => ({\n    isThemeTransitioning: true,\n    theme: state.theme === 'dark' ? 'light' : 'dark',\n    sceneRotation: state.sceneRotation + Math.PI, // 180도 회전 추가\n  }));\n\n  setTimeout(() => {\n    set({ isThemeTransitioning: false });\n  }, 2000); // 2초 후 전환 완료\n}"
          },
          {
            "title": "모바일 스와이프 각도 감지",
            "category": "mobile-ux",
            "description": "Why Angle Detection? 단순 X축 이동만 보면 세로 스크롤 중에도 수평 스와이프가 발동됩니다. Y축 이동량을 함께 추적하여 주된 터치 방향을 판별합니다.",
            "filePath": "src/components/ui/Modal.tsx",
            "githubLink": "https://github.com/sleepyMS/MS-Mind/blob/main/neural-nexus-portfolio/src/components/ui/Modal.tsx",
            "snippet": "const [touchStartY, setTouchStartY] = useState<number | null>(null);\nconst [touchEndY, setTouchEndY] = useState<number | null>(null);\n\nconst onTouchMove = (e: React.TouchEvent) => {\n  const currentX = e.targetTouches[0].clientX;\n  const currentY = e.targetTouches[0].clientY;\n  \n  // 수직 이동이 수평보다 크면 스크롤로 판단\n  const deltaX = Math.abs(currentX - touchStart);\n  const deltaY = Math.abs(currentY - touchStartY);\n  if (deltaY > deltaX) {\n    setSwipeOffset(0);  // 스와이프 무시\n    return;\n  }\n  // 수평 스와이프 처리...\n};"
          }
        ],
        "learnings": [
          {
            "title": "라이브러리 그 이상의 엔지니어링",
            "content": "d3-force나 R3F를 API대로 사용하는 것을 넘어, 물리 엔진 초기화 시점(Warm-up)을 직접 제어하고 수학 공식(Cubic Easing)을 애니메이션 루프에 주입하는 등 '블랙박스'를 열고 커스터마이징할 때 비로소 진정한 퀄리티가 나온다는 것을 배웠습니다."
          },
          {
            "title": "3D 인터페이스의 정보 밀도와 Subtraction의 미학",
            "content": "2D와 달리 3D 공간은 정보가 많아질수록 시각적 노이즈가 기하급수적으로 증가합니다. 연결선을 hover 시에만 표시하고, 카테고리 필터로 불필요한 노드를 숨기는 등 '덜어냄'이 3D UX의 핵심임을 깨달았습니다."
          },
          {
            "title": "수학은 엔지니어의 무기",
            "content": "applyAxisAngle(), lerpVectors(), easeInOutCubic 공식 등 벡터 수학과 보간 함수를 직접 다루면서, 라이브러리에 의존하지 않고도 복잡한 애니메이션을 구현할 수 있다는 자신감을 얻었습니다."
          },
          {
            "title": "React와 GPU의 경계에서 균형 잡기",
            "content": "React의 편의성과 GPU 렌더링의 성능 요구 사이에서 균형을 찾아야 합니다. UI 상태는 Zustand로, 애니메이션 변수는 useRef로 분리하여 '언제 React에게 맡기고, 언제 직접 제어할지'를 판단하는 기준을 세웠습니다."
          },
          {
            "title": "감각으로 전달되는 성능 최적화",
            "content": "사용자는 코드를 보지 않지만, 10ms의 hover 지연과 60fps의 카메라 움직임에서 '완성도'를 느낍니다. Dual Ref 패턴과 Transient Update 같은 최적화가 단순 기술 과시가 아닌, 사용자에게 '매끄럽고 기분 좋은 경험'을 선사하는 핵심 UX 요소임을 깨달았습니다."
          },
          {
            "title": "그래프 알고리즘의 실전 적용",
            "content": "대학에서 배운 BFS 알고리즘이 실제 프로덕트에서 '필터링된 노드 간 관계 유지'라는 UX 문제를 해결하는 핵심 도구가 되었습니다. CS 기초 지식이 단순 면접용을 넘어, 사용자 경험을 개선하는 실질적 무기가 된다는 것을 체감했습니다."
          },
          {
            "title": "터치 제스처의 '의도' 해석",
            "content": "모바일 터치는 단순 좌표가 아니라 사용자의 '의도'입니다. 수평 스와이프인지 수직 스크롤인지를 각도로 판별하고, 터치 시작 영역(탭/콘텐츠)에 따라 다른 동작을 부여하는 것이 진정한 모바일 UX 설계임을 배웠습니다."
          }
        ],
        "technologies": [
          "React",
          "Three.js",
          "R3F",
          "TypeScript",
          "Zustand",
          "d3-force-3d"
        ]
      },
      "color": "#c026d3"
    },
    {
      "id": "project-processing",
      "type": "project",
      "category": "creative",
      "label": "Processing Games",
      "connections": ["me", "skill-processing", "skill-arduino"],
      "details": {
        "description": "Processing으로 제작한 인터랙티브 게임 컬렉션입니다. Arduino 조이스틱 컨트롤을 통해 하드웨어와 소프트웨어를 연동했습니다.",
        "trouble": "Arduino 입력을 게임 상태와 동기화하고 다양한 게임 모드를 처리하는 것이 어려웠습니다.",
        "shooting": "모든 게임 모드에서 하드웨어 컨트롤을 추상화하는 모듈식 입력 시스템을 구축했습니다.",
        "lesson": "하드웨어-소프트웨어 통합에는 타이밍과 상태 관리에 대한 세심한 고려가 필요합니다.",
        "technologies": ["Processing", "Arduino", "Java"]
      },
      "color": "#10b981"
    },
    {
      "id": "skill-react",
      "type": "skill",
      "skillCategory": "framework",
      "label": "React 19",
      "connections": ["project-chatbot", "project-portfolio"],
      "details": {
        "description": "Meta에서 개발한 UI 라이브러리로, Hooks를 활용한 함수형 컴포넌트 개발을 지원합니다. 선언적 UI 패러다임과 Virtual DOM을 통해 효율적인 렌더링을 제공하며, Concurrent Mode와 Server Components 같은 최신 기능으로 대규모 애플리케이션 개발에 적합합니다."
      },
      "color": "#8b5cf6"
    },
    {
      "id": "skill-typescript",
      "type": "skill",
      "skillCategory": "language",
      "label": "TypeScript",
      "connections": ["project-chatbot", "project-cortex-fe"],
      "details": {
        "description": "Microsoft에서 개발한 JavaScript의 슈퍼셋으로, 정적 타입 검사를 통해 컴파일 시점에 오류를 잡아냅니다. 인터페이스, 제네릭, 유니온 타입 등 강력한 타입 시스템으로 대규모 애플리케이션의 안정성과 유지보수성을 크게 향상시킵니다."
      },
      "color": "#3b82f6"
    },
    {
      "id": "skill-threejs",
      "type": "skill",
      "skillCategory": "library",
      "label": "Three.js / R3F",
      "connections": ["project-portfolio"],
      "details": {
        "description": "WebGL 기반의 3D 그래픽 라이브러리로, 브라우저에서 고품질 3D 경험을 구현합니다. React Three Fiber(R3F)를 통해 React와 선언적으로 통합 가능하며, 커스텀 셰이더 작성, 포스트 프로세싱, 물리 엔진 연동 등 고급 그래픽 기법을 지원합니다."
      },
      "color": "#ec4899"
    },
    {
      "id": "skill-gsap",
      "type": "skill",
      "skillCategory": "library",
      "label": "GSAP",
      "connections": ["project-portfolio"],
      "details": {
        "description": "GreenSock Animation Platform의 약자로, 웹에서 가장 강력한 JavaScript 애니메이션 라이브러리입니다. 하드웨어 가속, 타임라인 기반 시퀀싱, ScrollTrigger 플러그인 등을 통해 부드럽고 성능 최적화된 애니메이션을 구현합니다."
      },
      "color": "#ec4899"
    },
    {
      "id": "skill-python",
      "type": "skill",
      "skillCategory": "language",
      "label": "Python",
      "connections": ["project-cortex", "project-paper-lstm"],
      "details": {
        "description": "데이터 분석, 머신러닝, 백엔드 개발 등 다양한 분야에서 활용되는 범용 프로그래밍 언어입니다."
      },
      "color": "#3b82f6"
    },
    {
      "id": "skill-fastapi",
      "type": "skill",
      "skillCategory": "framework",
      "label": "FastAPI",
      "connections": ["project-cortex"],
      "details": {
        "description": "Python 기반의 고성능 비동기 웹 프레임워크로, 자동 API 문서화와 타입 힌트 지원을 제공합니다."
      },
      "color": "#8b5cf6"
    },
    {
      "id": "skill-processing",
      "type": "skill",
      "skillCategory": "language",
      "label": "Processing",
      "connections": ["project-processing"],
      "details": {
        "description": "MIT 미디어 연구소에서 개발한 비주얼 아트와 크리에이티브 코딩을 위한 프로그래밍 언어 및 IDE입니다. Java 기반으로 동작하며, 인터랙티브 그래픽, 애니메이션, 데이터 시각화 등 시각 예술 작품을 쉽게 제작할 수 있습니다."
      },
      "color": "#3b82f6"
    },
    {
      "id": "skill-arduino",
      "type": "skill",
      "skillCategory": "tool",
      "label": "Arduino",
      "connections": ["project-processing"],
      "details": {
        "description": "오픈소스 하드웨어 플랫폼으로, 마이크로컨트롤러 기반의 프로토타이핑 보드입니다. 센서, 모터, LED 등 다양한 전자 부품을 제어할 수 있으며, IoT 프로젝트와 인터랙티브 설치 작품 개발에 널리 사용됩니다."
      },
      "color": "#f97316"
    },
    {
      "id": "skill-vite",
      "type": "skill",
      "skillCategory": "tool",
      "label": "Vite",
      "connections": ["project-chatbot"],
      "details": {
        "description": "차세대 프론트엔드 빌드 도구로, ES Modules 기반의 초고속 개발 서버와 HMR(Hot Module Replacement)을 제공합니다. Rollup 기반 번들링으로 최적화된 프로덕션 빌드를 생성하며, React, Vue, Svelte 등 다양한 프레임워크를 지원합니다."
      },
      "color": "#f97316"
    },
    {
      "id": "skill-tailwind",
      "type": "skill",
      "skillCategory": "framework",
      "label": "TailwindCSS",
      "connections": ["project-chatbot", "project-cortex-fe"],
      "details": {
        "description": "Utility-First 방식의 CSS 프레임워크로, 미리 정의된 유틸리티 클래스를 조합하여 빠르게 스타일링합니다. JIT 컴파일러로 사용된 클래스만 번들에 포함되어 최소한의 CSS 파일을 생성하며, 일관된 디자인 시스템 구축에 적합합니다."
      },
      "color": "#8b5cf6"
    },
    {
      "id": "skill-zustand",
      "type": "skill",
      "skillCategory": "library",
      "label": "Zustand",
      "connections": ["project-chatbot", "project-cortex-fe"],
      "details": {
        "description": "가볍고 빠른 React 상태 관리 라이브러리입니다. Redux 대비 보일러플레이트가 적고 러닝커브가 낮으며, 훅 기반의 직관적인 API를 제공합니다. Immer와 함께 사용하면 복잡한 중첩 상태도 쉽게 관리할 수 있습니다."
      },
      "color": "#ec4899"
    },
    {
      "id": "skill-axios",
      "type": "skill",
      "skillCategory": "library",
      "label": "Axios",
      "connections": ["project-chatbot"],
      "details": {
        "description": "Promise 기반의 HTTP 클라이언트로, 브라우저와 Node.js 환경 모두에서 동작합니다. 인터셉터를 통한 요청/응답 가로채기, 자동 JSON 변환, 요청 취소, 타임아웃 설정 등 API 통신에 필요한 다양한 기능을 제공합니다."
      },
      "color": "#ec4899"
    },
    {
      "id": "skill-i18next",
      "type": "skill",
      "skillCategory": "library",
      "label": "i18next",
      "connections": ["project-chatbot"],
      "details": {
        "description": "가장 널리 사용되는 JavaScript 국제화(i18n) 프레임워크입니다. 다국어 리소스 관리, 복수형 처리, 언어 감지, 지연 로딩 등 다국어 지원에 필요한 포괄적인 기능을 제공하며, React, Vue 등 다양한 프레임워크와 통합됩니다."
      },
      "color": "#ec4899"
    },
    {
      "id": "project-cortex",
      "type": "project",
      "category": "backend",
      "label": "Cortex-Backend",
      "connections": [
        "me",
        "skill-python",
        "skill-celery",
        "skill-redis",
        "skill-timescaledb",
        "skill-docker",
        "skill-postgresql",
        "project-cortex-fe"
      ],
      "details": {
        "description": "개인 투자자를 위한 데이터 기반 퀀트 투자 및 자동매매 플랫폼입니다. 단순한 CRUD API가 아닌, '실시간 금융 연산을 안정적으로 처리하면서 수백만 건의 시계열 데이터를 밀리초 단위로 조회'하는 것이 핵심 과제였습니다. CPU/IO 워커 분리, 베이지안 최적화, 복식부기 크레딧 시스템 등 엔터프라이즈급 아키텍처를 적용했습니다.",
        "technologies": [
          "FastAPI",
          "Celery",
          "Redis",
          "TimescaleDB",
          "PostgreSQL",
          "Docker",
          "Python 3.11"
        ],
        "coreFeatures": [
          "⚡ 벡터 연산 백테스팅: NumPy/Pandas로 45초→0.8초(98% 단축), Generator 기반 step-by-step 실행으로 Optuna 중간 Pruning 가능",
          "🔧 CPU/IO 워커 물리적 분리: cpu_queue(prefork)+io_queue(gevent)로 백테스팅 중에도 매매 주문 밀리초 체결 보장",
          "📊 TimescaleDB 시계열 최적화: 수억 건 OHLCV를 자동 청크 파티셔닝, (ticker, time DESC) 복합 인덱스로 조회 성능 유지",
          "💰 복식부기 크레딧 시스템: Ledger(생성)/Transaction(소비) 분리, 우선순위 FIFO 알고리즘(만료임박→무료→유료), UNION ALL로 통합 이력 조회",
          "🧠 WFO + Optuna 베이지안 최적화: Expanding Window 분할, TPE 샘플러로 유망 파라미터 집중 탐색, MedianPruner로 하위 50% 조기 중단"
        ],
        "techStackDocs": [
          {
            "name": "FastAPI",
            "description": "Why FastAPI over Django/Flask? Pydantic을 통한 엄격한 런타임 데이터 검증과 Native Async 지원이 필수적이었습니다. 금융 데이터의 정합성을 보장하면서도 High Concurrency를 처리하기 위한 최적의 선택입니다."
          },
          {
            "name": "Celery + Redis",
            "description": "Why Distributed Task Queue? 긴 실행 시간을 가지는 백테스팅 작업을 HTTP 요청 주기 내에서 처리하는 것은 불가능합니다. 작업을 큐에 넣고(Fire-and-Forget), 워커가 비동기로 처리하며, 진행률을 Pub/Sub으로 중계하는 패턴을 구축했습니다."
          },
          {
            "name": "TimescaleDB",
            "description": "Why not standard PostgreSQL? 수억 건의 캔들(OHLCV) 데이터 조회 시 B-Tree 인덱스만으로는 한계가 있습니다. 시간 기반 파티셔닝(Chunking)을 자동으로 관리해주는 TimescaleDB로 쿼리 속도를 유지했습니다."
          },
          {
            "name": "Docker",
            "description": "Why Single Image? API 서버, CPU 워커, I/O 워커가 동일한 코드베이스를 공유하되 실행 명령어(CMD)만 다르게 가져가는 전략으로, 빌드 시간을 단축하고 버전 불일치 문제를 해결했습니다."
          }
        ],
        "link": "https://github.com/sleepyMS/Cortex",
        "features": [
          {
            "title": "하이브리드 암호화 및 보안 전략 (Hybrid Cryptography)",
            "items": [
              "Dual Hashing Strategy: 비밀번호는 `Bcrypt`(느림, 강력함)로 해싱하여 무차별 대입 공격을 방어하고, 빈번한 인증이 필요한 토큰은 `HMAC-SHA256`(빠름, 안전함)으로 서명하여 보안과 성능의 균형을 맞췄습니다. (backend/app/security.py)",
              "Fernet Symmetric Encryption: DB에 저장되는 민감한 API Key는 `Fernet` 대칭키 알고리즘으로 암호화하여, 데이터 유출 시에도 복호화 키 없이는 사용할 수 없도록 보호했습니다.",
              "Why this mix? 모든 데이터를 Bcrypt로 처리하면 인증 부하가 커지고, 단순 해싱만으로는 원본 복구가 불가능한 API Key 저장 요구사항을 충족할 수 없어 용도별 최적의 알고리즘을 선택했습니다."
            ]
          },
          {
            "title": "비동기 분산 처리 시스템 (Async Distributed System)",
            "items": [
              "Layered Architecture: Router → Service → Repository(DB) 구조로 책임을 명확히 분리하여 유지보수성 향상",
              "Resource Isolation: 단일 Docker 이미지를 공유하지만 실행 CMD를 달리하여 워커 노드를 특성별(API/CPU/I/O)로 분리",
              "Message Broker: Redis를 브로커로 사용하여 서비스 간 결합도를 낮추고 비동기 작업 큐 관리"
            ]
          },
          {
            "title": "대용량 시계열 데이터 처리 (TimescaleDB)",
            "items": [
              "Hypertables 적용: 데이터를 시간 단위 청크(Chunk)로 자동 파티셔닝하여 디스크 I/O 최소화",
              "복합 인덱싱: (ticker, time DESC) 인덱스를 구성하여 최신 시세 조회 쿼리 속도 최적화"
            ]
          },
          {
            "title": "전략 최적화 고도화 (WFO + Optuna)",
            "items": [
              "WFO(Walk-Forward Optimization): 데이터를 Train/Test 구간으로 슬라이딩하며 검증하여 과최적화 방지",
              "베이지안 최적화(TPE): Optuna를 도입, 이전 파라미터의 성과를 학습하여 유망한 파라미터 영역 집중 탐색",
              "Aggressive Pruning: 각 Fold 검증 중 수익률이 하위 50% 미만이면 즉시 연산 중단(Early Stopping)",
              "성과: WFO로 10배 늘어난 연산 시간을 Pruning으로 1/5 수준으로 단축, 안정성과 속도 모두 확보"
            ]
          },
          {
            "title": "고급 분석 지표 및 시각화 데이터 처리 (Advanced Analytics)",
            "items": [
              "금융 지표 계산: Sharpe Ratio, Sortino Ratio, MDD, Win Rate, Profit Factor, CAGR 등 10여 가지 핵심 지표를 벡터 연산으로 고속 처리",
              "파라미터 중요도 분석: Optuna의 fANOVA (Functional Analysis of Variance) 알고리즘으로 수익률에 가장 큰 영향을 미친 파라미터를 정량적으로 추출하여 API로 제공",
              "평행좌표플롯 데이터 서빙: 수천 건의 Trial 데이터(params JSONB + metrics JSONB)를 고차원 시각화 포맷에 맞게 직렬화하고, 불필요한 필드를 제외하는 DTO 최적화로 전송량 절감",
              "파라미터 안정성 추이(Stability) 분석: WFO 수행 시 각 Fold별로 최적 파라미터가 어떻게 변해가는지 추적하여 전략의 과최적화 여부를 판단할 수 있는 시계열 데이터 제공"
            ]
          },
          {
            "title": "크레딧 경제 시스템 (Double-Entry Logic)",
            "items": [
              "Credits Ledger (원장): 크레딧의 '생성'을 기록하며, 각 레코드별로 만료일(expires_at)을 개별 관리",
              "Credits Transaction: 크레딧의 '소비'를 기록하고, transaction_details로 원장별 차감 내역 추적",
              "우선순위 알고리즘: [만료 임박 > 무료(보너스) > 유료] 순서로 자동 차감되는 FIFO 변형 로직"
            ]
          },
          {
            "title": "실시간 진행률 피드백 (Redis Pub/Sub + WebSocket)",
            "items": [
              "Celery 워커가 작업 진행 중 Redis Pub/Sub 채널로 진행률 메시지 발행",
              "FastAPI 서버가 해당 채널을 구독하고, 메시지 수신 즉시 WebSocket 클라이언트로 푸시",
              "폴링(Polling) 없이 실시간으로 부드러운 Progress UI 제공 및 서버 부하 감소"
            ]
          }
        ],
        "optimizations": [
          {
            "title": "Algorithm Vectorization으로 98% 성능 향상",
            "items": [
              "Why: Python For 루프로 수십만 캔들을 순회하며 지표 계산 시 수 분 소요. 사용자가 백테스트 버튼 클릭 후 멍하니 기다려야 하는 최악의 UX.",
              "How: Pandas/NumPy 벡터 연산으로 루프 제거, `np.where`로 조건문 벡터화, 컬럼 단위 일괄 처리. `df['signal'] = np.where((df['sma_short'] > df['sma_long']), 1, 0)` 패턴 적용.",
              "Impact: 1년 치 백테스팅 45초→0.8초로 98% 단축. 사용자가 '실시간'으로 여러 전략을 비교할 수 있는 경험 제공."
            ]
          },
          {
            "title": "Generator 기반 Step-by-Step 실행으로 중간 Pruning 가능",
            "items": [
              "Why: Optuna 최적화 시 Trial 중간에 수익률이 하위권이면 끝까지 실행할 필요 없음. 기존 run() 메서드는 '올-오어-낫씽'이라 조기 중단 불가.",
              "How: `run_step_by_step()` Generator 메서드 추가. 각 타임스텝마다 yield로 중간 결과 반환, 외부에서 `trial.should_prune()` 체크 후 중단 가능.",
              "Impact: WFO 10-Fold × 100 Trial = 1000회 실행 중 하위 50%를 중간에 중단하여 총 연산 시간 1/5로 단축."
            ]
          },
          {
            "title": "CPU/IO 워커 물리적 분리로 Starvation 해결",
            "items": [
              "Why: 백테스팅이 CPU 100%를 점유하면 같은 워커의 매매 주문 Task가 큐에서 대기. 급변하는 시장에서 주문 지연은 치명적 손실로 직결.",
              "How: `cpu_bound_queue`(prefork Pool, 프로세스 격리)와 `io_bound_queue`(gevent Pool, 코루틴 동시성)로 워커 이원화. Docker Compose로 별도 컨테이너 배포.",
              "Impact: 백테스팅 진행 중에도 매매 주문은 밀리초 단위 즉시 체결 보장."
            ]
          },
          {
            "title": "Eager Loading으로 N+1 쿼리 10배 개선",
            "items": [
              "Why: 전략 목록 조회 시 ORM Lazy Loading으로 백테스트, 파라미터 등 연관 데이터를 N번 추가 쿼리. 10개 전략에 100개 쿼리 발생하여 1.2초 지연.",
              "How: `selectinload(Strategy.backtests)`, `joinedload(Strategy.parameters)` 명시. 단 1회 JOIN 쿼리로 모든 연관 데이터 프리로딩.",
              "Impact: 전략 목록 API 응답 1.2s→0.1s로 10배 이상 개선."
            ]
          },
          {
            "title": "bulk_insert_mappings로 대량 데이터 저장 최적화",
            "items": [
              "Why: 최적화 Trial 1000개 결과를 개별 INSERT하면 1000회 DB 왕복. 네트워크 지연이 누적되어 저장만 수십 초 소요.",
              "How: SQLAlchemy `bulk_insert_mappings()`로 딕셔너리 리스트 일괄 삽입. ORM 오버헤드 없이 단일 트랜잭션 처리.",
              "Impact: Trial 저장 시간 30초→2초로 15배 단축."
            ]
          }
        ],
        "challenges": [
          {
            "title": "동기식 연산으로 인한 웹 서버 '동결' (The Frozen Server)",
            "problem": "초기에는 백테스팅을 FastAPI 엔드포인트 내부에서 직접 실행했습니다. Pandas 연산이 CPU를 점유하자 async 이벤트 루프가 멈춰버려, 헬스 체크를 포함한 모든 API 요청이 타임아웃되어 로드밸런서가 서버를 '죽은 것'으로 판단, 트래픽을 차단하는 치명적 장애가 발생했습니다.",
            "solution": "아키텍처를 근본적으로 변경했습니다. Celery를 도입하여 연산 작업을 별도 프로세스로 위임(Fire-and-Forget)하고, FastAPI는 '요청 접수 → 작업 ID 반환 → 진행률 조회'만 담당하도록 역할을 분리했습니다. Redis Pub/Sub으로 진행률을 WebSocket에 중계하여 폴링 없이 실시간 피드백을 구현했습니다."
          },
          {
            "title": "부동 소수점 연산 오차로 인한 거래소 API 오류",
            "problem": "Python `float`로 `0.1 BTC × 3 = 0.30000000000000004`가 되어 거래소 API에서 '잔액 부족' 또는 '정밀도 초과' 오류가 반환되었습니다. 특히 소수점 8자리까지 정밀도가 요구되는 암호화폐에서 이 문제는 실거래 손실로 직결될 수 있었습니다.",
            "solution": "모든 금전/수량 연산을 `Decimal` 타입으로 전환했습니다. DB 스키마(`Numeric(20, 8)`), Pydantic 모델(`condecimal`), 비즈니스 로직까지 일관된 정밀도를 적용하여 1사토시(0.00000001 BTC)의 오차도 허용하지 않았습니다."
          },
          {
            "title": "Celery Task 생성 전 DB 조회 시 Race Condition",
            "problem": "API에서 `backtest.delay(backtest_id)` 호출 직후 Celery 워커가 DB를 조회하면 아직 트랜잭션이 커밋되지 않아 'Backtest not found' 에러가 발생했습니다. 로컬에서는 발생하지 않다가 프로덕션에서만 간헐적으로 발생하여 디버깅이 어려웠습니다.",
            "solution": "워커 내부에 재시도 로직을 추가했습니다. `for attempt in range(5): ... time.sleep(1)` 패턴으로 DB 커밋을 기다리고, 여전히 없으면 명확한 에러 메시지와 함께 실패 처리합니다. 추가로 Celery의 `acks_late=True` 옵션으로 Task 완료 전 워커 충돌 시에도 재시도가 보장되도록 설정했습니다."
          },
          {
            "title": "크레딧 차감 시 원장 추적 불가 문제",
            "problem": "단순히 `user.credit_balance -= amount`로 차감하면 '어디서 획득한 크레딧이 어디에 사용되었는지' 추적이 불가능했습니다. 고객 환불 요청이나 감사(Audit) 시 근거 자료를 제시할 수 없는 심각한 비즈니스 리스크였습니다.",
            "solution": "복식부기(Double-Entry) 원칙을 적용했습니다. `CreditLedger`(생성 원장)와 `CreditTransaction`(소비 기록)을 분리하고, `CreditTransactionDetail`로 어떤 원장에서 얼마가 차감되었는지 추적합니다. 우선순위 알고리즘(만료임박→이벤트쿠폰→구매)으로 자동 차감하고, `UNION ALL`로 획득/사용 이력을 통합 조회하는 API를 제공합니다."
          }
        ],
        "learnings": [
          {
            "title": "MSA로 가는 징검다리: 모듈러 모놀리스",
            "content": "처음부터 MSA로 시작하면 인프라 복잡도(서비스 디스커버리, 분산 트랜잭션, 로그 통합)에 압도당합니다. 코드베이스는 하나로 유지하되 Auth/Backtest/Trade/Credit 등 도메인 간 직접 import를 금지하고, services/ 레이어를 통해서만 통신하는 규칙을 세웠습니다. 덕분에 필요 시 서비스를 '떼어내기만 하면' MSA로 전환할 수 있는 유연한 구조를 만들었습니다."
          },
          {
            "title": "CPU-bound vs I/O-bound: 물리적 격리의 필요성",
            "content": "`async/await`는 I/O 대기를 효율화할 뿐, CPU를 점유하는 연산은 결국 이벤트 루프를 블로킹합니다. 백테스팅(CPU)과 거래소 API 호출(I/O)을 논리적 분리(Queue)가 아닌 물리적 분리(별도 컨테이너)해야 진정한 격리가 가능함을 배웠습니다. prefork(멀티프로세스)와 gevent(코루틴)의 차이를 실제 장애를 통해 체득했습니다."
          },
          {
            "title": "금융 시스템에서 데이터 정합성은 타협 불가",
            "content": "전략 수정 후 과거 백테스트 결과가 바뀌면 사용자 신뢰가 무너집니다. 백테스트 실행 시점의 전략을 JSON 스냅샷으로 저장하여 불변성을 보장하고, Decimal 타입으로 연산 오차를 제거하며, 복식부기로 모든 크레딧 흐름을 추적합니다. '귀찮아서 나중에'가 아닌 '처음부터 정확하게'가 금융 시스템의 기본임을 배웠습니다."
          },
          {
            "title": "이벤트 기반 아키텍처의 유연함",
            "content": "`publish_event('backtest.completed', payload)` → `dispatch_event` Task가 구독자 Task들을 호출하는 Pub/Sub 패턴을 구현했습니다. 새로운 기능(예: 슬랙 알림) 추가 시 기존 코드 수정 없이 구독자만 등록하면 됩니다. 모듈 간 결합도를 낮추고 확장성을 높이는 설계 원칙을 체득했습니다."
          },
          {
            "title": "측정 없는 최적화는 추측에 불과하다",
            "content": "처음엔 '모든 쿼리에 인덱스를 걸어야 한다'고 생각했으나, 실제 프로파일링 결과 병목은 TimescaleDB의 시간 범위 쿼리와 N+1 문제뿐이었습니다. `EXPLAIN ANALYZE`와 SQLAlchemy 쿼리 로깅으로 실제 병목을 측정한 후 집중 개선하니 10배 성능 향상을 달성했습니다. '추측이 아닌 측정'이 엔지니어링의 기본임을 깨달았습니다."
          }
        ],
        "codeExamples": [
          {
            "title": "Generator 기반 Step-by-Step 백테스팅 (Pruning 가능)",
            "category": "performance",
            "description": "Why Generator? 최적화 시 수익률 하위권 Trial을 끝까지 돌리면 시간 낭비입니다. yield로 각 스텝마다 중간 결과를 반환하고, 외부에서 Optuna `trial.should_prune()` 체크 후 중단하여 연산 시간 1/5로 단축했습니다.",
            "filePath": "backend/app/engine/backtesting_engine.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/engine/backtesting_engine.py",
            "snippet": "def run_step_by_step(self) -> Generator[Dict, None, None]:\n    \"\"\"제너레이터로 단계별 실행. 외부에서 Pruning 제어 가능.\"\"\"\n    for timestamp, group in self.merged_df.groupby(level=0):\n        self.process_single_step(timestamp, group)\n        # 중간 결과 yield (Pruning 판단용)\n        if self.step_count % 100 == 0:\n            yield {\n                'is_intermediate': True,\n                'backtest_score': self._calculate_current_score(),\n                'mdd_pct': self._calculate_current_mdd()\n            }\n    yield self._calculate_summary_stats()  # 최종 결과"
          },
          {
            "title": "이벤트 기반 Pub/Sub 디스패처",
            "category": "architecture",
            "description": "Why Event-Driven? 백테스트 완료 시 이메일/슬랙/푸시 알림을 추가할 때마다 기존 코드를 수정하면 유지보수가 악몽이 됩니다. 이벤트 발행 후 구독자 Task만 등록하면 되는 느슨한 결합으로 확장성을 확보했습니다.",
            "filePath": "backend/app/tasks.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/tasks.py",
            "snippet": "@celery_app.task(name='dispatch_event', queue='io_bound_queue')\ndef dispatch_event(event_name: str, payload: dict):\n    EVENT_SUBSCRIBERS = {\n        'backtest.completed': ['send_backtest_notification_task'],\n        'optimization.completed': ['send_optimization_notification_task'],\n        'payment.succeeded': ['fulfill_order_task'],\n    }\n    if task_names := EVENT_SUBSCRIBERS.get(event_name):\n        for task_name in task_names:\n            celery_app.send_task(task_name, args=[payload])"
          },
          {
            "title": "복식부기 크레딧 차감 (우선순위 FIFO)",
            "category": "business",
            "description": "Why Double-Entry? 단순 `balance -= amount`는 '어디서 온 크레딧이 어디에 사용됐는지' 추적 불가. 환불/감사 시 근거 자료가 없으면 비즈니스 리스크입니다. Ledger별 차감 내역을 TransactionDetail로 기록하여 완전한 추적성을 확보했습니다.",
            "filePath": "backend/app/services/credit_service.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/services/credit_service.py",
            "snippet": "# 우선순위: 만료임박 > 이벤트쿠폰 > 구매\npriority_order = {'EVENT_COUPON': 1, 'ATTENDANCE': 2, 'PURCHASE': 3}\navailable_ledgers.sort(key=lambda l: (priority_order.get(l.source_type, 99), l.expires_at))\n\nfor ledger in available_ledgers:\n    if remaining <= 0: break\n    deduct = min(ledger.remaining_amount, remaining)\n    ledger.remaining_amount -= deduct\n    # 어떤 원장에서 얼마 차감했는지 상세 기록\n    transaction_details.append({'ledger_id': ledger.id, 'amount': deduct})"
          },
          {
            "title": "Celery 큐 분리로 CPU/I/O 격리",
            "category": "async",
            "description": "Why Segregation? CPU 100%를 쓰는 백테스팅 때문에 같은 워커의 매매 주문이 지연되면 급변하는 시장에서 치명적 손실입니다. 물리적으로 워커를 분리하여 백테스팅 중에도 주문은 밀리초 즉시 체결을 보장했습니다.",
            "filePath": "backend/app/tasks.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/tasks.py",
            "snippet": "@celery_app.task(name='run_backtest', queue='cpu_bound_queue', acks_late=True)\ndef run_backtest(backtest_id: str):\n    # prefork Pool: 멀티프로세스 → CPU 격리\n    ...\n\n@celery_app.task(name='execute_live_trade', queue='io_bound_queue')\ndef execute_live_trade(bot_id: str):\n    # gevent Pool: 코루틴 → I/O 동시성\n    ..."
          },
          {
            "title": "Optuna + WFO 베이지안 최적화 + MedianPruner",
            "category": "optimization",
            "description": "Why TPE+Pruning? Grid Search는 모든 조합을 탐색하여 비효율적입니다. TPE(Tree-structured Parzen Estimator)로 유망 영역을 집중 탐색하고, MedianPruner로 중간 성과가 하위 50%면 즉시 중단하여 10배 늘어난 WFO 연산을 1/5로 단축했습니다.",
            "filePath": "backend/app/tasks.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/tasks.py",
            "snippet": "sampler = optuna.samplers.TPESampler(seed=42)\npruner = optuna.pruners.MedianPruner(n_startup_trials=5, n_warmup_steps=10)\nstudy = optuna.create_study(direction='maximize', sampler=sampler, pruner=pruner)\n\nfor intermediate in engine.run_step_by_step():\n    if intermediate.get('is_intermediate'):\n        trial.report(intermediate['backtest_score'], step=step)\n        if trial.should_prune():\n            raise optuna.TrialPruned()  # 조기 중단"
          },
          {
            "title": "벡터 연산으로 백테스팅 98% 가속화",
            "category": "performance",
            "description": "Why Vectorization? Python For 루프로 수십만 캔들을 순회하면 수 분 소요. `np.where`로 조건문을 벡터화하고 컬럼 단위로 일괄 처리하여 45초→0.8초로 98% 단축했습니다.",
            "filePath": "backend/app/engine/backtesting_engine.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/engine/backtesting_engine.py",
            "snippet": "# For 루프 대신 벡터 연산\ndf['signal'] = np.where(\n    (df['sma_short'] > df['sma_long']) & \n    (df['sma_short'].shift(1) <= df['sma_long'].shift(1)),\n    1,   # 골든크로스: 매수\n    np.where(df['sma_short'] < df['sma_long'], -1, 0)  # 데드크로스: 매도\n)"
          },
          {
            "title": "Race Condition 방지: Task 내 재시도 로직",
            "category": "troubleshooting",
            "description": "Why Retry? API에서 commit 전에 Celery가 DB 조회하면 'Not Found'. 로컬에서는 안 생기다가 프로덕션에서만 간헐적 발생하여 디버깅이 악몽이었습니다. 워커 내부에서 5회 재시도하고, `acks_late=True`로 워커 충돌 시에도 재실행을 보장했습니다.",
            "filePath": "backend/app/tasks.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/tasks.py",
            "snippet": "@celery_app.task(bind=True, acks_late=True)\ndef run_backtest(self, backtest_id: str):\n    # 커밋 대기를 위한 재시도 로직\n    for attempt in range(5):\n        backtest = session.query(Backtest).filter_by(id=uuid).one_or_none()\n        if backtest: break\n        time.sleep(1)  # 트랜잭션 커밋 대기\n    if not backtest:\n        raise ValueError(f'Backtest {backtest_id} not found after 5 retries')"
          },
          {
            "title": "N+1 쿼리 문제 해결: Eager Loading",
            "category": "troubleshooting",
            "description": "Why Eager? ORM Lazy Loading으로 10개 전략 조회 시 100개 쿼리 발생하여 1.2초 지연. `selectinload`로 연관 데이터를 단 1회 쿼리로 프리로딩하여 0.1초로 10배 개선했습니다.",
            "filePath": "backend/app/routers/strategies.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/routers/strategies.py",
            "snippet": "# Before: N+1 문제 (1.2s, 100+ queries)\nstrategies = await db.execute(select(Strategy))\n\n# After: Eager Loading (0.1s, 2 queries)\nstrategies = await db.execute(\n    select(Strategy)\n    .options(selectinload(Strategy.backtests))\n    .options(selectinload(Strategy.parameters))\n)"
          },
          {
            "title": "bulk_insert로 대량 데이터 15배 빠른 저장",
            "category": "performance",
            "description": "Why Bulk? Trial 1000개 결과를 개별 INSERT하면 1000회 DB 왕복으로 수십 초 소요. `bulk_insert_mappings`로 딕셔너리 리스트를 단일 트랜잭션으로 일괄 삽입하여 30초→2초로 15배 단축했습니다.",
            "filePath": "backend/app/tasks.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/tasks.py",
            "snippet": "# 개별 INSERT 대신 Bulk Insert\ntrial_objects = []\nfor t in study.trials:\n    trial_objects.append({\n        'job_id': job_uuid, 'trial_id': t.number,\n        'params': t.params, 'metrics': t.user_attrs.get('metrics'),\n        'state': 'COMPLETE' if t.state == TrialState.COMPLETE else 'PRUNED'\n    })\nsession.bulk_insert_mappings(OptimizationTrial, trial_objects)"
          },
          {
            "title": "Decimal 타입으로 금융 정밀도 보장",
            "category": "troubleshooting",
            "description": "Why Decimal? `float`로 `0.1 BTC × 3 = 0.30000000000000004`가 되어 거래소 API에서 '잔액 부족' 오류. DB부터 Pydantic까지 `Decimal(20, 8)`로 통일하여 1사토시 오차도 허용하지 않습니다.",
            "filePath": "backend/app/schemas.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/schemas.py",
            "snippet": "from pydantic import condecimal\n\nclass OrderCreate(BaseModel):\n    quantity: condecimal(max_digits=20, decimal_places=8)\n    price: condecimal(max_digits=20, decimal_places=8)\n    # float 대신 Decimal로 정밀도 보장\n    # 0.1 + 0.2 == Decimal('0.3')  # True"
          },
          {
            "title": "UNION ALL로 통합 이력 효율적 조회",
            "category": "database",
            "description": "Why UNION? 획득(Ledger)과 사용(Transaction) 이력을 앱 레벨에서 합치면 두 번 쿼리 + 메모리 정렬이 필요합니다. DB 레벨에서 `UNION ALL`로 합치고 정렬/페이징하여 단일 쿼리로 처리했습니다.",
            "filePath": "backend/app/services/credit_service.py",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/backend/app/services/credit_service.py",
            "snippet": "gains_query = select(Ledger.created_at, Ledger.initial_amount.label('amount'), ...)\nusages_query = select(Transaction.created_at, (-Transaction.amount).label('amount'), ...)\n\n# DB에서 통합 + 정렬 + 페이징\nunified = union_all(gains_query, usages_query).alias('unified')\nfinal = select(unified).order_by(desc(unified.c.created_at)).offset(offset).limit(limit)"
          }
        ]
      },
      "color": "#f97316"
    },
    {
      "id": "skill-celery",
      "type": "skill",
      "skillCategory": "library",
      "label": "Celery",
      "connections": ["project-cortex"],
      "details": {
        "description": "분산 태스크 큐 시스템으로, CPU-bound와 I/O-bound 작업을 비동기로 처리합니다."
      },
      "color": "#ec4899"
    },
    {
      "id": "skill-redis",
      "type": "skill",
      "skillCategory": "database",
      "label": "Redis",
      "connections": ["project-cortex"],
      "details": {
        "description": "인메모리 데이터 저장소로, Message Broker 및 Pub/Sub 기반 실시간 통신에 활용됩니다."
      },
      "color": "#14b8a6"
    },
    {
      "id": "skill-timescaledb",
      "type": "skill",
      "skillCategory": "database",
      "label": "TimescaleDB",
      "connections": ["project-cortex"],
      "details": {
        "description": "PostgreSQL 기반의 시계열 데이터베이스로, 대용량 OHLCV 데이터 처리에 최적화되어 있습니다."
      },
      "color": "#14b8a6"
    },
    {
      "id": "skill-docker",
      "type": "skill",
      "skillCategory": "tool",
      "label": "Docker",
      "connections": ["project-cortex"],
      "details": {
        "description": "컨테이너 기반의 애플리케이션 배포 및 환경 일관성을 보장합니다."
      },
      "color": "#f97316"
    },
    {
      "id": "skill-postgresql",
      "type": "skill",
      "skillCategory": "database",
      "label": "PostgreSQL",
      "connections": ["project-cortex"],
      "details": {
        "description": "관계형 데이터베이스로, 사용자/전략/백테스트 데이터 저장 및 Optuna Study 공유 저장소로 활용됩니다."
      },
      "color": "#14b8a6"
    },
    {
      "id": "project-cortex-fe",
      "type": "project",
      "category": "frontend",
      "label": "Cortex-Frontend",
      "connections": [
        "me",
        "project-cortex",
        "skill-nextjs",
        "skill-typescript",
        "skill-tailwind",
        "skill-zustand",
        "skill-react-query",
        "skill-recharts",
        "skill-websocket"
      ],
      "details": {
        "description": "개인 투자자가 코딩 없이 투자 전략을 설계하고, 백테스팅 검증 후 자동매매까지 연결하는 올인원 퀀트 플랫폼의 프론트엔드입니다. 단순한 UI 구현을 넘어, '복잡한 금융 알고리즘을 비개발자도 설계할 수 있게 만드는 것'이 핵심 도전 과제였습니다. 이를 위해 재귀적 트리 구조 렌더링, 1000+ 라인의 차트 매니저 훅, Lock & Queue 패턴의 인증 시스템 등 엔터프라이즈급 아키텍처를 적용했습니다.",
        "technologies": [
          "Next.js 14 (App Router)",
          "TypeScript 5",
          "Tailwind CSS",
          "Zustand + Immer",
          "TanStack Query v5",
          "React Hook Form + Zod",
          "Lightweight Charts",
          "Recharts",
          "WebSocket"
        ],
        "coreFeatures": [
          "🔐 Lock & Queue 기반 Silent Auth Refresh: 동시 5개 API 호출 시 토큰 만료 Race Condition을 단일 갱신으로 해결, 트래픽 80% 절감",
          "📈 1062줄 차트 매니저 훅: 멀티 차트 시간축 동기화, 볼린저밴드/일목균형표 등 복합 지표 렌더링, Imperative Update로 50% 성능 향상",
          "🧠 재귀적 No-Code 전략 빌더: Discriminated Union 타입 시스템으로 7가지 로직 블록(Comparison/Crossover/State/Channel 등) 타입 안전 처리",
          "📊 커스텀 평행좌표 차트: 수천 Trial 결과를 SVG로 직접 렌더링, useMemo 기반 최적화로 300개 라인 실시간 인터랙션",
          "⚡ WebSocket → Query Cache 직접 동기화: API 재호출 없이 진행률 UI 즉시 갱신, 네트워크 트래픽 대폭 감소"
        ],
        "techStackDocs": [
          {
            "name": "Next.js 14 (App Router)",
            "description": "Why App Router? 퀀트 플랫폼은 대시보드 중심이라 SEO보다 코드 분할과 레이아웃 공유가 중요합니다. Route Groups로 인증/비인증 레이아웃을 분리하고, 동적 임포트로 150KB 차트 라이브러리를 지연 로딩하여 FCP를 40% 개선했습니다."
          },
          {
            "name": "TypeScript + Discriminated Unions",
            "description": "Why Union Types? 전략 빌더의 7가지 로직 블록(Comparison, Crossover, State, TrendSignal, Channel, Divergence, Pattern)을 단일 타입으로 처리해야 했습니다. Discriminated Union으로 type 필드에 따른 자동 타입 추론을 구현하여 런타임 에러를 컴파일 타임에 차단했습니다."
          },
          {
            "name": "Zustand + Immer",
            "description": "Why not Redux? 전략 빌더의 중첩 트리 구조(blocks[].children[].children[]...)를 업데이트할 때 Redux의 보일러플레이트는 과도합니다. Immer로 불변성을 자동 관리하고, 타겟 노드만 찾아 수정하는 findAndModify 유틸리티를 구현하여 코드량 70% 감축했습니다."
          },
          {
            "name": "TanStack Query v5",
            "description": "Why Query over SWR? 복잡한 캐시 조작이 필요했습니다. WebSocket 메시지로 setQueryData를 직접 호출하여 API 재요청 없이 UI를 갱신하고, invalidateQueries로 완료 시점에만 전체 리페칭하는 하이브리드 패턴을 구현했습니다."
          },
          {
            "name": "React Hook Form + Zod",
            "description": "Why not Formik? 조건 블록 50개 이상의 동적 폼에서 Formik은 전체 리렌더링을 유발합니다. useFieldArray로 개별 필드만 업데이트하고, Zod 스키마로 중첩 객체의 타입 안전 유효성 검사를 수행했습니다."
          },
          {
            "name": "Lightweight Charts",
            "description": "Why not D3/Recharts? 수만 개 캔들 데이터를 SVG로 렌더링하면 브라우저가 멈춥니다. TradingView의 Canvas 기반 라이브러리를 선택하되, React 상태와 분리된 Imperative Update 패턴으로 Virtual DOM 오버헤드를 회피했습니다."
          }
        ],
        "codeExamples": [
          {
            "title": "Lock & Queue 토큰 갱신 시스템",
            "category": "auth",
            "description": "Race Condition 해결의 정석. 대시보드 진입 시 5개 API가 동시에 401을 받으면 5번의 refresh 요청이 발생하고, 서버는 이를 토큰 탈취로 간주합니다. isRefreshing 플래그로 첫 401만 갱신을 시도하고, 나머지는 Promise Queue에 대기시켜 갱신 완료 후 일괄 재시도합니다.",
            "filePath": "frontend/src/lib/apiClient.ts",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/frontend/src/lib/apiClient.ts",
            "snippet": "let isRefreshing = false;\nlet failedQueue: Array<{resolve, reject}> = [];\n\nconst processQueue = (error, token) => {\n  failedQueue.forEach(p => error ? p.reject(error) : p.resolve(token));\n  failedQueue = [];\n};\n\napiClient.interceptors.response.use(res => res, async (error) => {\n  const originalRequest = error.config;\n  if (error.response?.status === 401 && !originalRequest._retry) {\n    if (isRefreshing) {\n      // 이미 갱신 중이면 Queue에 대기\n      return new Promise((resolve, reject) => {\n        failedQueue.push({ resolve, reject });\n      }).then(token => {\n        originalRequest.headers['Authorization'] = 'Bearer ' + token;\n        return apiClient(originalRequest);\n      });\n    }\n    originalRequest._retry = true;\n    isRefreshing = true;\n    const newToken = await useUserStore.getState().refreshSession();\n    processQueue(null, newToken);\n    isRefreshing = false;\n    return apiClient(originalRequest);\n  }\n  return Promise.reject(error);\n});"
          },
          {
            "title": "1062줄 차트 매니저 훅 (useChartIndicatorManager)",
            "category": "performance",
            "description": "React와 Canvas 라이브러리의 패러다임 충돌을 해결한 핵심 훅입니다. 멀티 차트 시간축 동기화, 볼린저밴드/켈트너채널/일목균형표 구름대 렌더링, 크로스헤어 연동, 테마 전환 등 복잡한 요구사항을 1062줄로 캡슐화했습니다.",
            "filePath": "frontend/src/hooks/useChartIndicatorManager.ts",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/frontend/src/hooks/useChartIndicatorManager.ts",
            "snippet": "// 멀티 차트 시간축 동기화\nchart.timeScale().subscribeVisibleTimeRangeChange((range) => {\n  const allCharts = [chartRef.current, ...paneCharts];\n  allCharts.forEach(otherChart => {\n    if (otherChart && otherChart !== chart) {\n      otherChart.timeScale().setVisibleRange(range);\n    }\n  });\n});\n\n// 볼린저밴드 구름대 렌더링\nconst cloudData = bbuData.map((d, i) => ({\n  time: d.time,\n  upperValue: d.value,\n  lowerValue: bblData[i]?.value,\n  color: 'rgba(33, 150, 243, 0.15)'\n}));\nmainChart.addCustomSeries(new CloudSeries(), { cloudColor });"
          },
          {
            "title": "Discriminated Union 기반 로직 블록 타입 시스템",
            "category": "architecture",
            "description": "7가지 조건 유형(비교, 크로스오버, 상태, 추세, 채널, 다이버전스, 패턴)을 하나의 Union 타입으로 관리합니다. type 필드로 구분되어 TypeScript가 각 블록의 필드를 자동 추론하므로, 런타임 타입 체크 없이 안전한 코드를 작성할 수 있습니다.",
            "filePath": "frontend/src/types/strategy.ts",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/frontend/src/types/strategy.ts",
            "snippet": "export interface ComparisonLogic {\n  id: string;\n  type: 'comparison';  // Discriminant\n  operandA: IndicatorValue | number | null;\n  operator: '>' | '<' | '==' | '!=';\n  operandB: IndicatorValue | number | null;\n  children?: LogicBlock[];\n}\n\nexport interface CrossoverLogic {\n  id: string;\n  type: 'crossover';  // Discriminant  \n  mainLine: IndicatorValue | number | null;\n  signalLine: IndicatorValue | number | null;\n  crossDirection: 'above' | 'below';\n}\n\n// Union Type: switch(block.type)으로 자동 타입 추론\nexport type LogicBlock = \n  | ComparisonLogic | CrossoverLogic | StateLogic \n  | TrendSignalLogic | ChannelLogic | DivergenceLogic | PatternLogic;"
          },
          {
            "title": "커스텀 평행좌표 차트 (ParallelCoordinatesChart)",
            "category": "visualization",
            "description": "수천 번의 최적화 Trial 결과를 시각화하는 고성능 SVG 차트입니다. useMemo로 데이터 전처리를 캐싱하고, 상위 300개만 샘플링하여 렌더링 성능을 보장합니다. Score 기반 색상/투명도 그라데이션으로 우수 파라미터 영역을 직관적으로 파악할 수 있습니다.",
            "filePath": "frontend/src/components/domain/optimization/ParallelCoordinatesChart.tsx",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/frontend/src/components/domain/optimization/ParallelCoordinatesChart.tsx",
            "snippet": "const { processedTrials, dimensions, maxScore } = useMemo(() => {\n  // 1. Score 기준 정렬 후 상위 300개만 샘플링\n  const sortedTrials = [...trials].sort((a, b) => \n    (b.metrics?.backtestScore ?? 0) - (a.metrics?.backtestScore ?? 0)\n  ).slice(0, 300);\n  \n  // 2. 숫자형 파라미터만 추출하여 축 생성\n  const paramKeys = Object.keys(trials[0].params)\n    .filter(key => typeof trials[0].params[key] === 'number')\n    .slice(0, 8);  // 최대 8개 축\n  \n  return { processedTrials: sortedTrials, dimensions, maxScore };\n}, [trials]);\n\n// Score 기반 색상 그라데이션\nconst getLineColor = (score, maxScore) => {\n  const normalized = score / maxScore;\n  if (normalized >= 0.8) return '#10b981';  // 상위 20%: 녹색\n  if (normalized >= 0.5) return '#3b82f6';  // 중상위: 파랑\n  return '#ef4444';  // 하위: 빨강\n};"
          },
          {
            "title": "WebSocket → Query Cache 직접 동기화",
            "category": "realtime",
            "description": "백테스팅 진행 중 매 초마다 API를 호출하면 서버 부하가 급증합니다. WebSocket 메시지를 수신하면 setQueryData로 TanStack Query 캐시를 직접 수정하여 UI를 즉시 갱신하고, 완료 시점에만 invalidateQueries로 전체 데이터를 리페칭합니다.",
            "filePath": "frontend/src/components/domain/backtesting/BacktestContent.tsx",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/frontend/src/components/domain/backtesting/BacktestContent.tsx",
            "snippet": "useEffect(() => {\n  if (backtest?.status === 'running') {\n    const ws = new WebSocket(`${wsUrl}/ws/backtest/${backtestId}`);\n    \n    ws.onmessage = (event) => {\n      const message = JSON.parse(event.data);\n      \n      // API 호출 없이 캐시 직접 수정 (Optimistic-like)\n      queryClient.setQueryData(['backtestCore', backtestId], (old) => ({\n        ...old,\n        progress: message.progress,\n        status: message.status,\n      }));\n      \n      // 완료 시에만 전체 데이터 리페칭\n      if (message.status === 'completed') {\n        queryClient.invalidateQueries({ queryKey: ['backtestCore', backtestId] });\n        queryClient.invalidateQueries({ queryKey: ['backtestCharts', backtestId] });\n      }\n    };\n    \n    return () => ws.close();\n  }\n}, [backtest?.status]);"
          },
          {
            "title": "935줄 전략 에디터 패널 (StrategyEditorPanel)",
            "category": "architecture",
            "description": "전략 CRUD의 모든 복잡성을 단일 컴포넌트에 응집시킨 핵심 UI입니다. React Hook Form + Zustand 이중 상태 관리, 실시간 차트 프리뷰, 디바운스된 API 호출, 스냅샷 복원 등 935줄의 밀도 높은 로직을 포함합니다.",
            "filePath": "frontend/src/components/domain/strategy/StrategyEditorPanel.tsx",
            "githubLink": "https://github.com/sleepyMS/Cortex/blob/main/frontend/src/components/domain/strategy/StrategyEditorPanel.tsx",
            "snippet": "// 폼 상태와 Zustand 상태의 독립적 Dirty 체크\nconst isZustandDirty = useMemo(() => {\n  if (!initialStrategyRef.current) {\n    return strategyState.longEntryRules?.blocks?.length > 0;\n  }\n  return JSON.stringify(strategyState.longEntryRules) !== \n         JSON.stringify(initialStrategyRef.current.longEntryRules);\n}, [strategyState]);\n\n// 규칙 변경 시 500ms 디바운스 후 차트 프리뷰 업데이트\nconst [debouncedRules, setDebouncedRules] = useState(currentRules);\nuseEffect(() => {\n  const timer = setTimeout(() => setDebouncedRules(currentRules), 500);\n  return () => clearTimeout(timer);\n}, [currentRules]);\n\n// 디바운스된 규칙으로 지표/시그널 데이터 페칭\nconst { data: indicatorData } = useQuery({\n  queryKey: ['indicators', chartTicker, chartTimeframe, indicatorConfigs],\n  queryFn: ({ signal }) => fetchIndicatorData(..., signal),\n  enabled: !!ohlcvData && indicatorConfigs.length > 0,\n});"
          }
        ],
        "link": "https://github.com/sleepyMS/Cortex",
        "deployLink": "https://cortex-five-eosin.vercel.app/",
        "features": [
          {
            "title": "Lock & Queue 기반 무중단 인증 시스템",
            "items": [
              "문제: 대시보드 진입 시 5개 API 동시 호출 중 토큰 만료 시 5번의 401과 5번의 refresh 요청 발생 → 서버가 토큰 탈취로 오인하여 강제 로그아웃",
              "해결: Axios Interceptor에 isRefreshing 플래그와 failedQueue 도입, 첫 401만 갱신 시도하고 나머지는 Promise Queue에 대기",
              "성과: 토큰 갱신 요청 80% 감소, 사용자는 만료를 전혀 인지하지 못하는 Seamless UX 제공"
            ]
          },
          {
            "title": "1062줄 캡슐화된 차트 매니저 훅",
            "items": [
              "복잡도: 멀티 팬 차트 시간축 동기화, 볼린저밴드/켈트너채널/일목균형표 구름대, 크로스헤어 Legend 연동, 테마 전환",
              "핵심 기법: React State 대신 useRef로 차트 인스턴스 관리 (Imperative Update), ResizeObserver로 반응형 처리",
              "성과: 차트 로딩 시간 50% 단축, 스크롤 시 60fps 유지, 메모리 누수 완전 방지"
            ]
          },
          {
            "title": "재귀적 No-Code 전략 빌더",
            "items": [
              "도전: IF (조건A AND (조건B OR 조건C)) 같은 복잡한 논리식을 코딩 없이 시각적으로 구성",
              "구현: Discriminated Union 타입으로 7종 로직 블록 정의, 재귀 컴포넌트로 무한 중첩 지원",
              "Zustand findAndModify: 트리 전체 순회 대신 ID로 타겟 노드만 정밀 업데이트하여 O(N) 최적화"
            ]
          },
          {
            "title": "커스텀 평행좌표 시각화 (ParallelCoordinatesChart)",
            "items": [
              "목적: 수천 번의 파라미터 최적화 Trial 결과를 한눈에 비교하여 우수 파라미터 영역 탐색",
              "기술: SVG 직접 렌더링, useMemo로 데이터 전처리 캐싱, 상위 300개 샘플링으로 성능 보장",
              "UX: Score 기반 색상/투명도 그라데이션, 호버 시 커스텀 툴팁으로 파라미터 상세 확인"
            ]
          },
          {
            "title": "병렬 데이터 페칭 + Progressive Loading",
            "items": [
              "패턴: 백테스팅 상세 페이지에서 [핵심 정보], [차트 데이터], [거래 로그] 3개 쿼리 독립 실행",
              "UX: 각 섹션별 독립 Skeleton UI, 차트 로딩 중에도 핵심 지표는 즉시 표시 (Blocking 방지)",
              "기술: TanStack Query의 enabled 옵션으로 의존성 있는 쿼리 순서 제어"
            ]
          },
          {
            "title": "서버/클라이언트 상태의 명확한 분리",
            "items": [
              "원칙: 데이터의 '출처'와 '변경 빈도'에 따라 상태 관리 도구 선택",
              "Server State (TanStack Query): API 데이터 (백테스트 결과, 유저 정보) - 캐싱, 재검증, 에러 핸들링",
              "Client State (Zustand): UI 상태 (다크모드, 사이드바) - 즉각 반영, 로컬 스토리지 동기화"
            ]
          }
        ],
        "optimizations": [
          {
            "title": "Imperative Update 패턴으로 차트 성능 50% 향상",
            "items": [
              "Why: Lightweight Charts는 내부 Canvas를 직접 조작하는데, React State 변경마다 전체 차트가 재생성되어 GC 폭발",
              "How: 차트 인스턴스를 useRef로 관리하고, series.setData() 직접 호출로 React Reconciler 우회",
              "Impact: 수만 개 캔들 로딩 시간 2초→1초, 스크롤 시 FPS 30→60, 메모리 사용량 40% 감소"
            ]
          },
          {
            "title": "useMemo 기반 대용량 데이터 전처리 캐싱",
            "items": [
              "Why: 평행좌표 차트에서 수천 Trial 데이터를 매 렌더마다 정렬/샘플링/정규화하면 UI 버벅거림",
              "How: useMemo로 전처리 결과 캐싱, trials 배열 참조가 변경될 때만 재계산",
              "Impact: 렌더링 시간 300ms→50ms, 호버 인터랙션 부드러움 보장"
            ]
          },
          {
            "title": "디바운스된 API 호출로 서버 부하 80% 감소",
            "items": [
              "Why: 전략 빌더에서 조건 수정마다 즉시 차트 프리뷰를 업데이트하면 초당 수십 번 API 호출",
              "How: 500ms setTimeout 디바운스 적용, useEffect cleanup으로 중복 요청 취소",
              "Impact: 지표 계산 API 호출 횟수 1/10 감소, 서버 비용 절감"
            ]
          },
          {
            "title": "next/dynamic으로 차트 라이브러리 지연 로딩",
            "items": [
              "Why: Lightweight Charts (~80KB) + Recharts (~70KB) = 150KB가 초기 번들에 포함되면 FCP 지연",
              "How: next/dynamic으로 차트 컴포넌트 분리, 뷰포트 진입 시점에 로딩",
              "Impact: 초기 번들 크기 150KB 감소, FCP 40% 개선"
            ]
          },
          {
            "title": "React.memo + Component Isolation으로 폼 성능 최적화",
            "items": [
              "Why: 조건 블록 50개의 동적 폼에서 하나의 입력 필드 변경이 전체 리렌더링 유발",
              "How: 각 입력 컴포넌트를 분리하고 React.memo 적용, useFieldArray로 개별 필드만 업데이트",
              "Impact: 50개 블록에서도 타이핑 지연 0ms, 메모리 사용량 30% 감소"
            ]
          }
        ],
        "challenges": [
          {
            "title": "치명적인 Race Condition: 5중 401 에러",
            "problem": "대시보드 진입 시 프로필/전략/백테스트/크레딧/알림 5개 API가 동시 호출됩니다. 토큰 만료 시 5번의 401 에러가 발생하고, 각각이 독립적으로 refresh를 시도하면 서버는 '동시에 여러 기기에서 토큰 갱신'으로 오인하여 보안상 전체 세션을 무효화했습니다.",
            "solution": "Axios Interceptor에 Lock & Queue 패턴을 도입했습니다. isRefreshing 플래그로 첫 401만 갱신을 시도하고, 이후 요청은 failedQueue에 Promise로 대기시킵니다. 갱신 완료 후 processQueue()로 대기 중인 모든 요청을 새 토큰과 함께 일괄 재시도하여, 갱신 요청을 1회로 줄이고 UX 끊김을 완전히 제거했습니다."
          },
          {
            "title": "React vs Canvas: 패러다임 충돌",
            "problem": "Lightweight Charts는 Canvas를 직접 조작하는 라이브러리입니다. 차트 데이터를 React State로 관리하면, 상태 변경마다 전체 차트가 파괴→재생성되어 1) 깜빡임 발생, 2) 이전 인스턴스의 메모리 누수, 3) GC로 인한 프레임 드랍이 발생했습니다.",
            "solution": "Imperative Update 패턴을 적용했습니다. 차트 인스턴스와 시리즈를 useRef로 관리하고, 데이터 변경 시 series.setData()를 직접 호출합니다. useEffect cleanup에서 chart.remove()를 호출하여 메모리 누수를 방지하고, 이 모든 로직을 1062줄의 useChartIndicatorManager 훅으로 캡슐화하여 재사용성을 확보했습니다."
          },
          {
            "title": "Two Sources of Truth: 폼 vs 전역 상태 비동기화",
            "problem": "React Hook Form의 빠른 타이핑을 Zustand 스토어가 따라가지 못해, 저장 버튼 클릭 시 이전 버전의 데이터가 서버로 전송되었습니다. useEffect로 동기화하려 했으나 무한 루프와 성능 저하만 야기했습니다.",
            "solution": "역할 분리 원칙을 적용했습니다. 입력 중에는 React Hook Form이 로컬 상태로 데이터를 관리하고, 저장 버튼 클릭 시 handleSubmit 내부에서 Zustand로 최종값을 전달하는 단방향 흐름을 구축했습니다. 추가로 isDirty 상태를 이중으로 추적(폼 vs 스토어)하여 변경사항 유실 방지 다이얼로그를 구현했습니다."
          },
          {
            "title": "복잡한 중첩 구조의 타입 안전성",
            "problem": "전략 빌더는 7가지 타입의 로직 블록이 무한히 중첩될 수 있습니다. 각 블록 타입마다 다른 필드를 가지므로, 런타임에 'Cannot read property of undefined' 에러가 빈번했습니다.",
            "solution": "TypeScript의 Discriminated Union을 활용했습니다. 모든 블록에 type 필드를 추가하고, LogicBlock = ComparisonLogic | CrossoverLogic | ... 형태로 정의했습니다. switch(block.type) 문에서 TypeScript가 자동으로 해당 타입의 필드만 추론하므로, 존재하지 않는 필드 접근을 컴파일 타임에 차단할 수 있었습니다."
          }
        ],
        "learnings": [
          {
            "title": "라이브러리 추상화 수준의 이해",
            "content": "Lightweight Charts처럼 DOM을 직접 조작하는 라이브러리는 React의 Virtual DOM 패러다임과 충돌합니다. 단순히 useEffect 안에서 사용하는 것이 아니라, 라이브러리의 생명주기를 React 생명주기와 명시적으로 동기화(생성→업데이트→Cleanup)해야 한다는 점을 깊이 이해했습니다. 이 경험은 향후 D3, Three.js 등 다른 명령형 라이브러리 통합에도 적용 가능합니다."
          },
          {
            "title": "상태 관리 도구 선택의 기준",
            "content": "'데이터의 출처'가 상태 관리 도구 선택의 핵심 기준입니다. 서버에서 오는 데이터는 캐싱, 재검증, 에러 핸들링이 필요하므로 TanStack Query가 적합하고, 클라이언트에서 생성되는 UI 상태는 Zustand로 빠르게 처리합니다. 이 원칙을 세우고 나니 '어디에 상태를 둘까'라는 고민이 사라졌습니다."
          },
          {
            "title": "타입 시스템의 진정한 가치",
            "content": "TypeScript를 '자동완성 도구'로만 생각했으나, Discriminated Union을 활용하며 '런타임 에러를 컴파일 타임으로 끌어오는 도구'라는 본질을 깨달았습니다. 복잡한 도메인 로직일수록 타입 설계에 시간을 투자하면 디버깅 시간이 기하급수적으로 줄어듭니다."
          },
          {
            "title": "추상화의 적정 수준",
            "content": "모든 로직을 커스텀 훅으로 분리하려다 오히려 코드 추적이 어려워지는 경험을 했습니다. useChartIndicatorManager처럼 1000줄 이상의 복잡한 로직은 훅으로 분리하되, 단순한 API 호출 정도는 컴포넌트 내부에 두는 것이 '응집도' 관점에서 더 나은 설계임을 배웠습니다."
          },
          {
            "title": "성능 최적화는 측정 후에",
            "content": "처음엔 '모든 컴포넌트에 React.memo를 붙여야 한다'고 생각했으나, 실제로 Chrome DevTools로 측정해보니 병목은 차트 렌더링과 대용량 폼 뿐이었습니다. '추측이 아닌 측정'에 기반한 최적화가 효율적이라는 엔지니어링 원칙을 체득했습니다."
          }
        ]
      },
      "color": "#c026d3"
    },
    {
      "id": "skill-nextjs",
      "type": "skill",
      "skillCategory": "framework",
      "label": "Next.js",
      "connections": ["project-cortex-fe"],
      "details": {
        "description": "React 기반의 풀스택 프레임워크로, App Router와 서버 컴포넌트를 활용한 최적화된 웹 애플리케이션 개발에 사용됩니다."
      },
      "color": "#8b5cf6"
    },
    {
      "id": "skill-react-query",
      "type": "skill",
      "skillCategory": "library",
      "label": "TanStack Query",
      "connections": ["project-cortex-fe"],
      "details": {
        "description": "서버 상태 관리 라이브러리로, 비동기 데이터 페칭, 캐싱, 동기화를 효율적으로 처리합니다."
      },
      "color": "#ec4899"
    },
    {
      "id": "skill-recharts",
      "type": "skill",
      "skillCategory": "library",
      "label": "Recharts",
      "connections": ["project-cortex-fe"],
      "details": {
        "description": "React 기반 차트 라이브러리로, 재사용 가능한 차트 컴포넌트를 제공합니다."
      },
      "color": "#ec4899"
    },
    {
      "id": "skill-websocket",
      "type": "skill",
      "skillCategory": "tool",
      "label": "WebSocket",
      "connections": ["project-cortex-fe"],
      "details": {
        "description": "양방향 실시간 통신 프로토콜로, 백테스팅 진행률 등 실시간 UI 업데이트에 활용됩니다."
      },
      "color": "#f97316"
    },
    {
      "id": "project-paper-lstm",
      "type": "project",
      "category": "ai-ml",
      "label": "LSTM_암호화폐_논문-AI",
      "connections": ["me", "skill-python", "skill-lstm", "skill-tensorflow"],
      "details": {
        "description": "KCI 등재 학술논문으로, LSTM 기반 고가·저가 예측 모델을 활용한 암호화폐 선물거래 시스템을 연구했습니다. 기존 종가 기반 예측 모델 대신 고가/저가 데이터를 활용하여 선물거래에서 실질적인 수익률 개선을 달성했습니다.",
        "technologies": [
          "Python",
          "TensorFlow/Keras",
          "LSTM",
          "Pandas",
          "NumPy",
          "Matplotlib"
        ],
        "coreFeatures": [
          "📊 고가·저가 기반 LSTM 예측 모델",
          "💹 암호화폐 선물거래 시스템 (롱/숏 포지션)",
          "� 평균 +28.3% 수익률 개선 (ETH/XRP/DOGE)",
          "🎯 DOGE 최대 +45.96% 수익률 향상"
        ],
        "techStackDocs": [
          {
            "name": "LSTM (Long Short-Term Memory)",
            "description": "RNN의 장기 의존성 문제를 해결하고, 노이즈가 많은 금융 시계열 데이터에서도 안정적이고 일관된 예측 성능을 보이는 딥러닝 모델."
          },
          {
            "name": "TensorFlow 2.15 / Keras 2.15",
            "description": "Google Colab 환경에서 LSTM 모델 구현 및 학습에 사용. Adam 옵티마이저(lr=0.001)와 MSE 손실 함수 적용."
          },
          {
            "name": "MinMaxScaler",
            "description": "시계열 데이터 정규화를 위한 스케일링 처리. 타임스탬프 길이 14로 데이터 전처리."
          }
        ],
        "link": "https://www.kci.go.kr/kciportal/ci/sereArticleSearch/ciSereArtiView.kci?sereArticleSearchBean.artiId=ART003239433",
        "features": [
          {
            "title": "데이터 수집 및 전처리",
            "items": [
              "바이낸스 거래소 데이터 (TradingView 추출)",
              "대상: ETH, XRP, DOGE (BTC 추종 주요 알트코인)",
              "기간: 2022.02.01 ~ 2023.12.31 (약 2년)",
              "타임스탬프 길이 14, MinMaxScaler 정규화",
              "데이터 분할: 훈련 60% / 검증 20% / 테스트 20%"
            ]
          },
          {
            "title": "LSTM 모델 아키텍처",
            "items": [
              "환경: Google Colab + Python 3.10 + TensorFlow 2.15",
              "LSTM 레이어 2개 (256 → 128 유닛) + Dense 2개 (64 → 1 유닛)",
              "Dropout 0.05 적용, Adam 옵티마이저 (lr=0.001)",
              "손실 함수: MSE, 배치 크기 32, 에포크 100"
            ]
          },
          {
            "title": "선물거래 수익률 계산 시스템",
            "items": [
              "롱 포지션: 예측가 < 당일 고가 → 예측가에서 청산",
              "숏 포지션: 예측가 > 당일 저가 → 예측가에서 청산",
              "일별 Stop-Loss: 예측가 미도달 시 당일 종가로 청산",
              "매일 새 포지션 설정으로 시장 상황 대응"
            ]
          },
          {
            "title": "정량적 성과 비교",
            "items": [
              "ETH: Pearson 0.973→0.946, 승률 80.1%→77.9%, 수익률 +6.27%",
              "XRP: Pearson 0.962→0.914, 승률 72.2%→69.5%, 수익률 +32.71%",
              "DOGE: Pearson 0.969→0.930, 승률 75.1%→73.6%, 수익률 +45.96%",
              "특이점: DOGE 종가 모델 -13.19% → 고가/저가 모델 +32.77%"
            ]
          }
        ],
        "optimizations": [
          {
            "title": "선물거래 특화 타겟 설계",
            "items": [
              "가격 상승일: 고가(High)를 예측 타겟으로 설정",
              "가격 하락일: 저가(Low)를 예측 타겟으로 설정",
              "기존 종가 예측과 달리 변동 범위를 예측하여 수익 극대화"
            ]
          },
          {
            "title": "과적합 방지 기법",
            "items": [
              "EarlyStopping: 검증 손실 10에포크 미개선 시 훈련 중단",
              "최적 가중치 자동 복원 (restore_best_weights)",
              "Dropout 0.05로 LSTM 레이어 정규화"
            ]
          },
          {
            "title": "24시간 시장 특성 반영",
            "items": [
              "암호화폐 시장 연중무휴 특성 고려",
              "일별 단위 포지션으로 빠른 변동성 대응",
              "급격한 가격 변동을 고가/저가 피쳐로 포착"
            ]
          }
        ],
        "challenges": [
          {
            "title": "Transformer vs LSTM 모델 선택",
            "problem": "TFT, FEDformer 등 최신 Transformer 모델이 다중 피쳐 통합에 강점을 보이지만, 결과의 변동성이 크고 노이즈에 취약함. 암호화폐처럼 피쳐가 단순(OHLC)하고 노이즈가 극단적인 환경에서 적합한지 의문.",
            "solution": "Bilokon & Qiu (2023) 연구를 참고하여, 단순 피쳐 + 고변동성 환경에서는 LSTM의 반복적 기억 구조가 과적합 없이 더 안정적으로 작동함을 확인. 복잡성 최소화와 안정성을 동시에 추구."
          },
          {
            "title": "예측 정확도 vs 실제 수익률 괴리",
            "problem": "고가/저가 기반 모델은 Pearson 상관계수와 승률이 종가 기반 모델보다 낮음 (예: ETH 0.973→0.946). 전통적인 예측 성능 지표로는 모델의 실효성을 판단하기 어려움.",
            "solution": "선물거래의 본질인 '수익률'을 핵심 평가 지표로 설정. 상관계수/승률이 낮더라도 실제 수익률이 높으면 유효한 모델로 판단. DOGE에서 종가 모델 -13.19% vs 고가/저가 모델 +32.77%로 검증."
          },
          {
            "title": "데이터 복잡성과 모델 성능 트레이드오프",
            "problem": "고가/저가를 동시에 예측하면 데이터 복잡성이 증가하여 예측 정확도가 일부 하락함.",
            "solution": "선물거래에서는 정확한 방향 예측보다 가격 범위 예측이 더 중요함을 실험으로 입증. 수익률 관점에서 복잡성 증가가 오히려 이점으로 작용."
          }
        ],
        "learnings": [
          {
            "title": "왜 Transformer가 아닌 LSTM인가",
            "content": "Bilokon & Qiu (2023)의 'Transformers versus LSTMs for electronic trading' 연구에 따르면, 단순한 OHLC 피쳐와 높은 변동성 환경에서는 Transformer의 복잡한 Attention보다 LSTM의 반복적 기억 구조가 과적합 없이 더 견고하게 작동합니다."
          },
          {
            "title": "예측 성능 ≠ 수익 성능",
            "content": "Pearson 상관계수와 승률이 높다고 실제 수익률이 높은 것은 아닙니다. 선물거래의 특성(롱/숏 레버리지)을 반영한 수익률 지표로 모델을 평가해야 실질적인 성과를 측정할 수 있습니다."
          },
          {
            "title": "도메인 지식이 피쳐 설계를 결정",
            "content": "선물거래에서 롱/숏 포지션의 수익 구조를 이해하고, 이에 맞게 고가/저가 데이터를 예측 타겟으로 설정한 것이 기존 종가 예측 연구와의 핵심 차별점입니다."
          },
          {
            "title": "변동성이 클수록 효과가 큼",
            "content": "상대적으로 변동성이 낮은 ETH는 +6.27%, 중간인 XRP는 +32.71%, 고변동성인 DOGE는 +45.96%의 수익률 개선을 보였습니다. 고가/저가 접근법은 특히 고변동성 자산에서 효과적입니다."
          },
          {
            "title": "향후 연구 방향",
            "content": "TFT, FEDformer, PatchTST, TimesNet 등 최신 시계열 알고리즘 비교, SHAP 분석과 Attention 가중치 시각화를 통한 피쳐 중요도 분석, 뉴스/소셜미디어 감성 분석 통합 등으로 확장 가능합니다."
          }
        ],
        "references": [
          {
            "id": 1,
            "title": "Crypto-assets: Economic Nature, Classification and Regulation of Turnover",
            "authors": "D. Kochergin",
            "year": "2022",
            "source": "Int. Organ. Res. J., Vol. 17, No. 3, pp. 75-113"
          },
          {
            "id": 2,
            "title": "The Cross-section of Crypto-currencies as Financial Assets: An Overview",
            "authors": "H. Elendner, S. Trimborn, B. Ong, T. M. Lee",
            "year": "2016",
            "source": "SFB 649 Discussion Paper"
          },
          {
            "id": 3,
            "title": "Automation and Machine Learning in Transforming the Financial Industry",
            "authors": "P. K. Donepudi",
            "year": "2019",
            "source": "Asian Business Review, Vol. 9, No. 3, pp. 129-138"
          },
          {
            "id": 4,
            "title": "Artificial Intelligence Driven Crypto Currencies",
            "authors": "A. Ganapathy, M. Redwanuzzaman, M. M. Rahaman, W. Khan",
            "year": "2020",
            "source": "Global Disclosure of Economics and Business, Vol. 9, No. 2, pp. 107-118"
          },
          {
            "id": 5,
            "title": "A Deep Reinforcement Learning Approach for Automated Cryptocurrency Trading",
            "authors": "G. Lucarelli and M. Borrotti",
            "year": "2019",
            "source": "Proc. of AIAI 2019, pp. 247-258"
          },
          {
            "id": 6,
            "title": "Understanding LSTM—A Tutorial into Long Short-term Memory Recurrent Neural Networks",
            "authors": "R. C. Staudemeyer and E. R. Morris",
            "year": "2019",
            "source": "arXiv:1909.09586"
          },
          {
            "id": 7,
            "title": "Time Series Analysis of Cryptocurrency Prices Using Long Short-term Memory",
            "authors": "J. P. Fleischer, G. von Laszewski, C. Theran, Y. J. Parra Bautista",
            "year": "2022",
            "source": "Algorithms, Vol. 15, No. 7, p. 230"
          },
          {
            "id": 8,
            "title": "Transformers versus LSTMs for electronic trading",
            "authors": "P. Bilokon and Y. Qiu",
            "year": "2023",
            "source": "arXiv:2309.11400"
          },
          {
            "id": 9,
            "title": "Forecasting Cryptocurrency Prices Using LSTM, GRU, and Bi-directional LSTM: A Deep Learning Approach",
            "authors": "P. L. Seabe, C. R. B. Moutsinga, E. Pindza",
            "year": "2023",
            "source": "Fractal and Fractional, Vol. 7, No. 2, p. 203"
          },
          {
            "id": 10,
            "title": "A Novel Cryptocurrency Price Prediction Model Using GRU, LSTM and Bi-LSTM Machine Learning Algorithms",
            "authors": "M. J. Hamayel and A. Y. Owda",
            "year": "2021",
            "source": "AI, Vol. 2, No. 4, pp. 477-496"
          },
          {
            "id": 11,
            "title": "Enhancing Price Prediction in Cryptocurrency Using Transformer Neural Network and Technical Indicators",
            "authors": "M. A. L. Khaniki and M. Manthouri",
            "year": "2024",
            "source": "arXiv:2403.03606"
          },
          {
            "id": 12,
            "title": "LSTM Based Sentiment Analysis for Cryptocurrency Prediction",
            "authors": "X. Huang et al.",
            "year": "2021",
            "source": "Proc. of DASFAA 2021, pp. 617-621"
          },
          {
            "id": 13,
            "title": "Forecasting Directional Bitcoin Price Returns Using Aspect-based Sentiment Analysis on Online Text Data",
            "authors": "E. Loginova et al.",
            "year": "2024",
            "source": "Machine Learning, Vol. 113, No. 7, pp. 4761-4784"
          },
          {
            "id": 14,
            "title": "Sentiment-driven Price Prediction of the Bitcoin Based on Statistical and Deep Learning Approaches",
            "authors": "G. Serafini et al.",
            "year": "2020",
            "source": "Proc. of IJCNN 2020, pp. 1-8"
          },
          {
            "id": 15,
            "title": "Algorithmic Trading of Cryptocurrency Based on Twitter Sentiment Analysis",
            "authors": "S. Colianni, S. Rosales, M. Signorotti",
            "year": "2015",
            "source": "CS229 Project, Vol. 1, No. 5, pp. 1-4"
          },
          {
            "id": 16,
            "title": "Price Movement Prediction of Cryptocurrencies Using Sentiment Analysis and Machine Learning",
            "authors": "F. Valencia, A. Gómez-Espinosa, B. Valdés-Aguirre",
            "year": "2019",
            "source": "Entropy, Vol. 21, No. 6, p. 589"
          },
          {
            "id": 17,
            "title": "Sentiment Analysis of News for Effective Cryptocurrency Price Prediction",
            "authors": "A.-D. Vo, Q.-P. Nguyen, C.-Y. Ock",
            "year": "2019",
            "source": "Int. J. Knowl. Eng., Vol. 5, No. 2, pp. 47-52"
          },
          {
            "id": 18,
            "title": "Breaking News Headlines: Impact on Trading Activity in the Cryptocurrency Market",
            "authors": "A. K. Kulbhaskar and S. Subramaniam",
            "year": "2023",
            "source": "Econ. Model., Vol. 126, p. 106397"
          },
          {
            "id": 19,
            "title": "Investigating the Informativeness of Technical Indicators and News Sentiment in Financial Market Price Prediction",
            "authors": "S. A. Farimani et al.",
            "year": "2022",
            "source": "Knowl.-Based Syst., Vol. 247, p. 108742"
          },
          {
            "id": 20,
            "title": "Bitcoin Futures—What Use Are They?",
            "authors": "S. Corbet, B. Lucey, M. Peat, S. Vigne",
            "year": "2018",
            "source": "Econ. Lett., Vol. 172, pp. 23-27"
          },
          {
            "id": 21,
            "title": "The Impacts of Futures Trading on Volatility and Volatility Asymmetry of Bitcoin Returns",
            "authors": "C. Zhang, H. Ma, G. B. Arkorful, Z. Peng",
            "year": "2023",
            "source": "Int. Rev. Financ. Anal., Vol. 86, p. 102497"
          }
        ],
        "pdfLink": "/pdf/LSTM_Cryptocurrency_Future_Prediction_Model.pdf",
        "image": "/images/lstm/Deep_learning_architecture_flow_chart.png",
        "performance": [
          {
            "title": "알트코인 데이터 유형별 예측 성능 비교",
            "description": "기존 종가 기반 모델(Basic)과 제안된 고가/저가 기반 모델(Improved)의 예측 성능 비교입니다. 고가/저가 모델은 변동성 예측에 집중하여 상관계수와 승률은 소폭 낮지만, 실제 수익률 개선에 기여합니다.",
            "headers": ["Altcoin", "Model", "Pearson Correlation", "Win Rate"],
            "rows": [
              ["ETH", "Basic Data", "0.973", "80.1%"],
              ["ETH", "Improved Data", "0.946", "77.9%"],
              ["XRP", "Basic Data", "0.962", "72.2%"],
              ["XRP", "Improved Data", "0.914", "69.5%"],
              ["DOGE", "Basic Data", "0.969", "75.1%"],
              ["DOGE", "Improved Data", "0.930", "73.6%"]
            ]
          },
          {
            "title": "알트코인 데이터 유형별 수익률 비교",
            "description": "제안된 고가/저가 모델(Improved Data)이 기존 모델 대비 모든 코인에서 더 높은 수익률을 기록했습니다. 특히 변동성이 큰 DOGE, XRP에서 큰 폭의 개선을 보였습니다.",
            "headers": [
              "Altcoin",
              "Basic Data Profit",
              "Improved Data Profit",
              "Gain"
            ],
            "rows": [
              ["ETH", "30.78%", "37.05%", "+6.27%"],
              ["XRP", "64.78%", "97.49%", "+32.71%"],
              ["DOGE", "-13.19%", "32.77%", "+45.96%"]
            ]
          },
          {
            "title": "DOGE 가격 예측 결과 분석",
            "description": "종가 데이터 기반(a)은 실제와 유사하지만, 고가/저가 데이터 기반(b)이 변동성을 더 잘 반영하여 수익률이 높음.",
            "image": "/images/lstm/DOGE_Price_Prediction_Results.png"
          },
          {
            "title": "데이터 전처리 과정",
            "description": "MinMaxScaler 스케일링 및 60:20:20 데이터 분할 전략.",
            "image": "/images/lstm/Data_preprocessing.png"
          }
        ]
      },
      "color": "#8b5cf6"
    },
    {
      "id": "project-paper-tft",
      "type": "project",
      "category": "ai-ml",
      "label": "Dual-Stream_TFT_논문-AI",
      "connections": [
        "me",
        "skill-python",
        "skill-transformer",
        "skill-pytorch"
      ],
      "details": {
        "description": "일본 오사카 리츠메이칸 대학교 컨퍼런스에서 발표한 논문으로, Dual-Stream Temporal Fusion Transformer를 활용한 암호화폐 가격 예측 시스템을 연구했습니다. 가격 지표와 감성 데이터를 분리된 스트림으로 처리하고 동적 게이팅 메커니즘으로 융합하여 일반화 성능과 모델 해석력을 동시에 개선했습니다.",
        "technologies": [
          "Python 3.10",
          "PyTorch 2.1.0",
          "Lightning 2.5.1",
          "Temporal Fusion Transformer",
          "Optuna",
          "CUDA 11.8"
        ],
        "coreFeatures": [
          "🔀 Dual-Stream 아키텍처 설계",
          "📊 가격 + 감성 데이터 독립 처리",
          "🎯 MAE 2.31% 개선 / RMSE 2.28% 개선 / Vol 1.31% 개선",
          "🔍 Attention 기반 해석 가능성"
        ],
        "techStackDocs": [
          {
            "name": "Temporal Fusion Transformer (TFT)",
            "description": "Variable Selection Network와 Gating 메커니즘을 통해 불필요한 피쳐를 억제하고 중요 변수를 강조하는 해석 가능한 시계열 예측 모델."
          },
          {
            "name": "PyTorch + Lightning",
            "description": "PyTorch 2.1.0과 Lightning 2.5.1을 사용한 딥러닝 모델 구현. CUDA 11.8 GPU 가속 활용."
          },
          {
            "name": "Optuna",
            "description": "자동화된 하이퍼파라미터 탐색을 위한 프레임워크. 배치 크기, hidden size, dropout, learning rate 최적화."
          }
        ],
        "features": [
          {
            "title": "데이터 수집 및 전처리",
            "items": [
              "BTC OHLCV 데이터: Binance API (시간 단위)",
              "소셜 감성 점수: Santiment API (sentiment_balance_total, soc_sr)",
              "뉴스 감성 점수: Alpha Vantage API (ticker_sentiment_score, news_sr)",
              "기술 지표: MA, RSI 계산",
              "뉴스 감성에 4시간 반감기 지수 감쇠 적용",
              "데이터 분할: 훈련 70% / 검증 15% / 테스트 15%"
            ]
          },
          {
            "title": "Dual-Stream TFT 아키텍처",
            "items": [
              "Price Stream: BTC 가격 데이터 + 기술 지표 (MA, RSI)",
              "Sentiment Stream: 소셜 감성 + 뉴스 감성 + 변화율",
              "각 스트림별 독립 TFT 인코더",
              "Gated Fusion: α = σ(gate([yp, ys])), ŷ = α·yp + (1-α)·ys"
            ]
          },
          {
            "title": "정량적 성과 비교",
            "items": [
              "Validation: MAE 320.78 (+0.47%), RMSE 484.13 (-0.24%)",
              "Test: MAE 350.01 (-2.31%), RMSE 555.69 (-2.28%)",
              "예측 변동성 1.31% 감소로 안정성 향상",
              "Single-stream 대비 일반화 성능 개선 확인"
            ]
          },
          {
            "title": "Attention 분석 결과",
            "items": [
              "Price Stream: 후반 타임스텝(15-23)으로 점진적 집중",
              "Sentiment Stream: 10, 17, 21 타임스텝에서 sharp peak",
              "두 스트림 간 차별화된 시간적 패턴 확인",
              "모델 해석 가능성 향상"
            ]
          }
        ],
        "optimizations": [
          {
            "title": "동적 게이팅 메커니즘",
            "items": [
              "가격/감성 스트림 출력을 concat 후 gating layer 적용",
              "각 타임스텝별 스트림 기여도 가중치 학습",
              "해석 가능성: 게이트 가중치로 스트림 중요도 시각화"
            ]
          },
          {
            "title": "하이퍼파라미터 최적화",
            "items": [
              "Optuna 기반 자동 탐색",
              "배치 크기, hidden size, dropout, learning rate 최적화",
              "시나리오별 독립적 최적화 수행"
            ]
          },
          {
            "title": "감성 데이터 전처리",
            "items": [
              "뉴스 감성에 반감기 지수 감쇠 적용 (4시간)",
              "감성 부재 구간 명시적 0값 유지",
              "1차 변화율(sr) 계산으로 스케일 정규화"
            ]
          }
        ],
        "challenges": [
          {
            "title": "이종 데이터 소스 융합",
            "problem": "기존 Single-stream 방식은 가격/감성 데이터를 단일 입력으로 병합하여 각 모달리티의 고유 특성이 희석되고, cross-modal 상호작용 해석이 제한됨.",
            "solution": "Dual-Stream 아키텍처로 각 스트림이 모달리티 특화 시간적 표현을 학습하도록 분리. 동적 게이팅으로 융합하여 일반화 성능과 해석 가능성 동시 확보."
          },
          {
            "title": "Validation vs Test 성능 괴리",
            "problem": "Dual-Stream 모델의 Validation MAE가 Single-stream 대비 0.47% 높았으나, Test에서는 2.31% 더 낮은 성능을 보임.",
            "solution": "이종 데이터 동적 융합이 과적합을 방지하고 일반화를 강화함을 입증. Single-stream의 mid-sequence 과집중 문제를 해결."
          },
          {
            "title": "시간적 중요도 해석",
            "problem": "Single-stream 모델에서 attention이 분산되어 일관된 시간적 패턴 해석이 어려움.",
            "solution": "Dual-Stream에서 Price stream은 후반 집중, Sentiment stream은 특정 시점 peak로 명확히 분리되어 해석 가능성 향상."
          }
        ],
        "learnings": [
          {
            "title": "모달리티 분리의 중요성",
            "content": "가격 데이터와 감성 데이터는 본질적으로 다른 시간적 패턴을 가집니다. 이를 분리하여 처리하면 각 모달리티의 고유 특성을 보존하면서 더 정교한 융합이 가능합니다."
          },
          {
            "title": "Validation ↗ but Test ↘ 가 의미하는 것",
            "content": "Validation 성능이 약간 떨어져도 Test 성능이 개선되면 일반화 능력이 향상된 것입니다. 과적합 방지와 모델의 견고성이 실전에서 더 중요합니다."
          },
          {
            "title": "Attention 시각화로 해석 가능성 확보",
            "content": "TFT의 attention 가중치를 시각화하면 모델이 언제 어떤 정보에 집중하는지 알 수 있습니다. Price stream의 recent bias와 Sentiment stream의 event-driven peak가 명확히 구분됩니다."
          },
          {
            "title": "향후 연구 방향",
            "content": "동적 융합 메커니즘 고도화, 외생 변수(거시경제 지표 등) 추가 스트림 통합, 다중 모달 예측 프레임워크의 확장성 및 견고성 검증이 가능합니다."
          }
        ],
        "references": [
          {
            "id": 1,
            "title": "Temporal Fusion Transformers for Interpretable Multi-horizon Time Series Forecasting",
            "authors": "B. Lim, S. Ö. Arik, N. Loeff, T. Pfister",
            "year": "2019",
            "source": "arXiv:1912.09363"
          },
          {
            "id": 2,
            "title": "Cryptocurrency Price Prediction using Twitter Sentiment Analysis",
            "authors": "G. B. Haritha and N. B. Sahana",
            "year": "2023",
            "source": "arXiv:2303.09397"
          },
          {
            "id": 3,
            "title": "Price Prediction of Cryptocurrency Using User Sentiments and Quantitative Data",
            "authors": "D. Perera, J. Lim, S. Gunraku, W. H. Lim",
            "year": "2024",
            "source": "Proc. 2024 Int. Conf. Data Sci. Adv. Analytics"
          }
        ],
        "performance": [
          {
            "title": "시나리오별 성능 비교",
            "description": "Validation Set에서는 미세한 차이를 보였으나, Test Set에서는 Scenario 2(Dual-Stream)가 모든 지표에서 우수한 성능을 기록하여 일반화 능력이 입증되었습니다.",
            "headers": [
              "Scenario",
              "Val_MAE",
              "Val_RMSE",
              "Val_Vol",
              "Test_MAE",
              "Test_RMSE",
              "Test_Vol"
            ],
            "rows": [
              [
                "Scenario 1",
                "319.2764",
                "485.3020",
                "483.9223",
                "358.3081",
                "568.6622",
                "562.9303"
              ],
              [
                "Scenario 2",
                "320.7794",
                "484.1341",
                "483.5529",
                "350.0146",
                "555.6910",
                "555.5461"
              ]
            ]
          },
          {
            "title": "제안된 시스템 아키텍처",
            "description": "Price Stream과 Sentiment Stream을 분리하여 처리하고 Gated Fusion을 통해 결합하는 Dual-Stream 구조입니다.",
            "image": "/images/tft/Proposed Model System Architecture.svg"
          },
          {
            "title": "Attention 분포 분석 (Scenario 1 vs 2)",
            "description": "Scenario 1(위)은 Attention이 분산되어 패턴 해석이 어려운 반면, Scenario 2(아래)는 Price Stream이 후반부에 집중하고 Sentiment Stream이 특정 이벤트에 반응하는 명확한 패턴을 보입니다.",
            "image": "/images/tft/Encoder attention distribution in Scenario 2 (a price stream, b sentiment stream).svg"
          },
          {
            "title": "Scenario 1 Attention 분포 (참고)",
            "description": "Single-Stream 모델인 Scenario 1의 Attention 분포입니다. 특정 패턴 없이 분산된 형태를 보여줍니다.",
            "image": "/images/tft/Encoder attention distribution in Scenario 1.png"
          }
        ],
        "pdfLink": "/pdf/Conference_Paper_Dual-Stream-TFT.pdf",
        "image": "/images/tft/Proposed Model System Architecture.svg"
      },
      "color": "#8b5cf6"
    },
    {
      "id": "skill-lstm",
      "type": "skill",
      "skillCategory": "library",
      "label": "LSTM",
      "connections": ["project-paper-lstm"],
      "details": {
        "description": "Long Short-Term Memory 네트워크로, 시계열 데이터의 장기 의존성을 학습할 수 있는 RNN 아키텍처입니다."
      },
      "color": "#ec4899"
    },
    {
      "id": "skill-tensorflow",
      "type": "skill",
      "skillCategory": "framework",
      "label": "TensorFlow",
      "connections": ["project-paper-lstm"],
      "details": {
        "description": "Google에서 개발한 오픈소스 딥러닝 프레임워크로, 신경망 모델 구축 및 학습에 사용됩니다."
      },
      "color": "#8b5cf6"
    },
    {
      "id": "skill-transformer",
      "type": "skill",
      "skillCategory": "library",
      "label": "Transformer",
      "connections": ["project-paper-tft"],
      "details": {
        "description": "Self-Attention 메커니즘을 기반으로 한 딥러닝 아키텍처로, 시계열 예측과 NLP에서 뛰어난 성능을 보입니다."
      },
      "color": "#ec4899"
    },
    {
      "id": "skill-pytorch",
      "type": "skill",
      "skillCategory": "framework",
      "label": "PyTorch",
      "connections": ["project-paper-tft"],
      "details": {
        "description": "Facebook에서 개발한 오픈소스 딥러닝 프레임워크로, 동적 계산 그래프와 직관적인 API를 제공합니다."
      },
      "color": "#8b5cf6"
    }
  ]
}
